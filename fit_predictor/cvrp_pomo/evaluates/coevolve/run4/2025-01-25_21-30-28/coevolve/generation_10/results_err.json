{
  "generation": 10,
  "description": "The proposed solution for the Capacitated Vehicle Routing Problem (CVRP) integrates a dynamic and adaptive heuristic framework to achieve optimal route configurations under strict capacity constraints. This approach encompasses a multi-faceted strategy that leverages advanced optimization techniques, including:\n\n1. A hybrid iterative optimization process that synergistically employs both the Normalization and Inverse Distance heuristics to systematically refine node sequences, ensuring efficient allocation of customer demands and minimizing total travel distance.\n2. A robust load balancing mechanism designed to dynamically distribute demands among vehicles, thereby guaranteeing adherence to vehicle capacity limits and preventing overcapacity scenarios.\n3. The implementation of a state-of-the-art heuristic range adjustment mechanism that actively expands or contracts the search space based on the performance of previously evaluated solutions, thereby promoting deeper exploration of the solution space and enhancing solution quality.\n4. An iterative improvement phase that utilizes a combination of normalization and inverse distance heuristics to iteratively optimize the balance and efficiency of the route configurations.\n\nThe resultant algorithm is engineered to be highly robust and adaptable, capable of efficiently resolving complex CVRP instances with a focus on achieving balanced and optimal routes that minimize travel time. It strictly adheres to vehicle capacity and demand constraints, maximizing resource utilization and delivering a solution that is both efficient and effective.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    \n    # Normalize the demands\n    normalized_demands = demands / total_capacity\n    \n    # Calculate the Normalization heuristic (sum of normalized demands at each node)\n    normalization_heuristic = normalized_demands.sum(dim=1)\n    \n    # Calculate the Inverse Distance heuristic (inverse of the distance matrix)\n    inverse_distance_heuristic = 1 / distance_matrix\n    \n    # Calculate the weighted sum of the heuristics\n    # Weights can be adjusted as needed to favor one heuristic over the other\n    alpha = 0.5  # Example weight for Normalization heuristic\n    combined_heuristic = alpha * normalization_heuristic + (1 - alpha) * inverse_distance_heuristic\n    \n    # Ensure negative values for undesirable edges\n    combined_heuristic[distance_matrix == 0] = 0  # Avoid division by zero\n    combined_heuristic[combined_heuristic < 0] = 0  # Set undesirable edges to zero\n    \n    return combined_heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 12, in heuristics_v2\n    normalization_heuristic = normalized_demands\n                              ^^^^^^^^^^^^^^^^^^^\nIndexError: Dimension out of range (expected to be in range of [-1, 0], but got 1)\n",
      "stdout_file": "coevolve\\generation_10\\stdout_5.txt",
      "code_file": "coevolve\\generation_10\\code_5.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Normalize the demands by the total vehicle capacity\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Calculate the Normalization heuristic\n    # Each customer has a demand that contributes positively to the heuristic\n    normalization_heuristic = normalized_demands\n\n    # Calculate the Inverse Distance heuristic\n    # Each customer's distance to the depot is used to weigh its contribution negatively\n    inverse_distance_heuristic = -distance_matrix[:, 0] / (distance_matrix[:, 0] ** 2 + 1e-8)\n\n    # Combine the two heuristics using element-wise addition\n    combined_heuristic = normalization_heuristic + inverse_distance_heuristic\n\n    return combined_heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 99, in forward\n    attention_bias_current_node = self.attention_bias[torch.arange(batch_size)[:, None], state.current_node, :] if IMPL_REEVO else None\n                                  ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: too many indices for tensor of dimension 2\n",
      "stdout_file": "coevolve\\generation_10\\stdout_6.txt",
      "code_file": "coevolve\\generation_10\\code_6.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the inverse of the demands, which are normalized by total vehicle capacity\n    inverse_demands = 1.0 / (demands - demands.min())\n\n    # Compute the inverse distance heuristic: lower distances should be more promising\n    inverse_distance = 1.0 / distance_matrix\n\n    # Compute the Normalization heuristic: normalize distances by demands\n    # This step gives higher priority to closer customers that are under-demand\n    normalization = distance_matrix * inverse_demands\n\n    # The Normalization heuristic gives a negative score for under-demand and positive for over-demand\n    # We convert this to a promising score (negative for undesirable, positive for promising)\n    # by negating the Normalization heuristic values\n    normalization = -normalization\n\n    # Combine the heuristics using a weighted sum\n    # You can adjust the weights (alpha and beta) as needed for the specific problem instance\n    alpha = 0.5\n    beta = 0.5\n    combined_heuristic = alpha * inverse_distance + beta * normalization\n\n    return combined_heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 52, in pre_forward\n    assert not torch.isnan(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_10\\stdout_7.txt",
      "code_file": "coevolve\\generation_10\\code_7.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Ensure that the distance matrix and demands are on the same device and of the same dtype\n    distance_matrix = distance_matrix.to(demands.device).to(demands.dtype)\n    demands = demands.to(distance_matrix.device).to(distance_matrix.dtype)\n\n    # Calculate the inverse of the demands to represent the urgency of service\n    inverse_demands = 1 / demands\n\n    # Apply the Normalization heuristic\n    # This heuristic assigns a value based on the distance to the nearest node\n    # and the urgency of the demand.\n    min_distances = torch.min(distance_matrix, dim=1, keepdim=True)[0]\n    normalization_heuristic = (inverse_demands * min_distances).unsqueeze(1)\n\n    # Apply the Inverse Distance heuristic\n    # This heuristic assigns a value inversely proportional to the distance.\n    inverse_distance_heuristic = (inverse_demands * (distance_matrix ** 2)).unsqueeze(1)\n\n    # Combine the two heuristics using a weighted sum (weights can be adjusted)\n    # For simplicity, we'll use equal weights, but these can be tuned.\n    combined_heuristic = (normalization_heuristic + inverse_distance_heuristic) / 2\n\n    # Subtract the combined heuristic from the demands to get negative values for undesirable edges\n    # and positive values for promising ones.\n    heuristics = demands - combined_heuristic\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 52, in pre_forward\n    assert not torch.isnan(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_10\\stdout_8.txt",
      "code_file": "coevolve\\generation_10\\code_8.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the inverse distance heuristic values\n    inverse_distance = 1 / distance_matrix\n    \n    # Normalize the demands to get the Normalization heuristic values\n    normalized_demands = demands / demands.sum()\n    \n    # Calculate the sum of heuristics\n    combined_heuristics = inverse_distance + normalized_demands\n    \n    # Subtract the sum from the maximum value to ensure all values are negative for undesirable edges\n    max_combined_heuristic = combined_heuristics.max()\n    heuristics = combined_heuristics - max_combined_heuristic\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 52, in pre_forward\n    assert not torch.isnan(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_10\\stdout_11.txt",
      "code_file": "coevolve\\generation_10\\code_11.py"
    }
  ]
}