{
  "generation": 8,
  "description": "Design an optimized heuristic algorithm for solving the Capacitated Vehicle Routing Problem (CVRP) that minimizes total travel distance while adhering to vehicle capacity constraints. The algorithm must iteratively refine route sequences by utilizing inverse distance and demand normalization heuristics to optimize the allocation of customer demands and reduce the overall distance traveled. Implement load balancing strategies to ensure vehicle capacities are not exceeded, and adjust vehicle routes dynamically to enhance load distribution. Further enhance the search process with a heuristic range adjustment to expand the solution space based on previous solution performance. The algorithm should be robust, capable of adapting to real-world scenarios, and provide balanced, optimal solutions that minimize travel time while maximizing resource utilization, adhering to strict capacity and demand constraints of the vehicles.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the inverse distance matrix\n    inverse_distance_matrix = 1.0 / distance_matrix\n\n    # Normalize demands by the total vehicle capacity\n    normalized_demands = demands / demands.sum()\n\n    # Combine inverse distance and normalized demand to get the heuristic values\n    # Note: The sum of all heuristic values should be equal to the sum of all demands\n    # as we normalize the demands to be a probability distribution.\n    heuristics = -inverse_distance_matrix * normalized_demands\n\n    # Clip the values to ensure that they are within a reasonable range\n    heuristics = torch.clamp(heuristics, min=-1.0, max=1.0)\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 52, in pre_forward\n    assert not torch.isnan(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_8\\stdout_1.txt",
      "code_file": "coevolve\\generation_8\\code_1.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Calculate the inverse of the distance matrix\n    inv_distance_matrix = 1 / (distance_matrix + 1e-8)  # Add a small constant to avoid division by zero\n    \n    # Normalize the inverse distance matrix by the demand to get the initial heuristic\n    normalized_inv_distance_matrix = inv_distance_matrix * (1 / demands)\n    \n    # Adjust the heuristic values based on the inverse of the demand (heuristic range adjustment)\n    # Negative values indicate less promising edges, while positive values indicate more promising ones\n    heuristic_matrix = -normalized_inv_distance_matrix * (1 / demands)\n    \n    # Sum up the heuristics along the diagonal (excluding the depot itself)\n    # The sum represents the potential total distance if we visit all customers\n    sum_heuristics = torch.sum(heuristic_matrix[1:], dim=0)\n    \n    # Normalize the heuristic matrix by the sum to get the relative importance of each edge\n    relative_heuristic_matrix = heuristic_matrix / sum_heuristics\n    \n    return relative_heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 52, in pre_forward\n    assert not torch.isnan(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_8\\stdout_6.txt",
      "code_file": "coevolve\\generation_8\\code_6.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Normalize demands to be in the range [0, 1]\n    normalized_demands = demands / demands.sum()\n    \n    # Compute inverse distance matrix\n    inverse_distance_matrix = 1 / distance_matrix\n    \n    # Compute weighted demands for each edge based on the demand of the destination\n    # and the inverse distance\n    weighted_demands = normalized_demands.unsqueeze(1) * inverse_distance_matrix\n    \n    # Add a small constant to avoid division by zero\n    epsilon = 1e-6\n    weighted_demands = weighted_demands + epsilon\n    \n    # Normalize the weighted demands matrix so that the sum of values in each row is 1\n    heuristic_matrix = weighted_demands / weighted_demands.sum(dim=1, keepdim=True)\n    \n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 52, in pre_forward\n    assert not torch.isnan(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_8\\stdout_7.txt",
      "code_file": "coevolve\\generation_8\\code_7.py"
    }
  ]
}