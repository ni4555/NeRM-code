{
  "generation": 8,
  "description": "The revised heuristic for the Capacitated Vehicle Routing Problem (CVRP) merges evolutionary optimization with local search to efficiently plan delivery routes under strict capacity limits. It features:\n\n1. A robust evolutionary algorithm with:\n   - Adaptive genetic operators for improved solution quality.\n   - Selection, crossover, and mutation methods to maintain solution diversity.\n\n2. A refined local search that:\n   - Uses swap-insertion and 2-opt heuristics for capacity-aware route optimization.\n   - Incorporates real-time penalties to prevent overloading while enhancing route efficiency.\n\n3. Normalization techniques to equalize customer demand for fair solution evaluation.\n   - Constraint-aware optimization to allocate capacities effectively.\n\n4. Dynamic neighborhood and diversity management to explore the solution space and avoid local optima.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Calculate the initial heuristic based on customer demand\n    demand_heuristic = normalized_demands\n\n    # Incorporate distance heuristic by subtracting the distance\n    distance_heuristic = -distance_matrix\n\n    # Combine demand and distance heuristics\n    combined_heuristic = demand_heuristic + distance_heuristic\n\n    # Real-time penalties to prevent overloading\n    # Assuming a penalty factor for each customer\n    penalty_factor = torch.clamp(distance_matrix / max(distance_matrix), min=0, max=1)\n    penalty_heuristic = penalty_factor * combined_heuristic\n\n    # Apply normalization to the heuristics\n    # Assuming that we want to prevent very large heuristics\n    max_heuristic = torch.max(penalty_heuristic)\n    normalized_heuristics = penalty_heuristic / max_heuristic\n\n    return normalized_heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 20, in heuristics_v2\n    return heuristics\n                      \nRuntimeError: Boolean value of Tensor with more than one value is ambiguous\n",
      "stdout_file": "coevolve\\generation_8\\stdout_2.txt",
      "code_file": "coevolve\\generation_8\\code_2.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.size(0)\n    vehicle_capacity = demands.sum()\n    normalized_demands = demands / vehicle_capacity\n\n    # Step 1: Calculate initial heuristic based on normalized demands\n    demand_heuristic = -normalized_demands[None, :] @ distance_matrix.T\n\n    # Step 2: Apply 2-opt heuristic for capacity-aware route optimization\n    # Note: This is a simplified version of the 2-opt heuristic that doesn't change the distance matrix\n    # but rather adjusts the heuristic based on potential savings from improving the route\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if i + 1 < j:  # Ensure the subtour is not trivial\n                # Calculate the savings if the subtour from i, j-1, ..., i+1, j is optimized\n                savings = -torch.abs((distance_matrix[i, j] - distance_matrix[i, j - 1] -\n                                      distance_matrix[i + 1, j] + distance_matrix[i + 1, j - 1]))\n                demand_heuristic[i, j] += savings\n\n    # Step 3: Apply swap-insertion heuristic\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            # Consider swapping customer i with customer j\n            # Here, we simulate this by considering a change in heuristic for swap\n            swap_savings = -torch.abs((distance_matrix[i, j] - distance_matrix[i, j - 1] -\n                                      distance_matrix[i + 1, j] + distance_matrix[i + 1, j - 1]))\n            demand_heuristic[i, j] += swap_savings\n\n    # Step 4: Incorporate real-time penalties to prevent overloading\n    # This step requires information about the current route load, which is not provided here.\n    # Assuming that the distance_matrix contains both distances and the load at each node:\n    # distance_matrix = torch.cat([distance_matrix, load_matrix], dim=1)\n    # for i in range(1, n):\n    #     for j in range(i + 2, n):\n    #         # Assume the last column of distance_matrix contains load information\n    #         load_penalty = max(0, distance_matrix[i, j].item() - vehicle_capacity)\n    #         demand_heuristic[i, j] -= load_penalty\n\n    return demand_heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 21, in heuristics_v2\nIndexError: index 1 is out of bounds for dimension 0 with size 1\n",
      "stdout_file": "coevolve\\generation_8\\stdout_6.txt",
      "code_file": "coevolve\\generation_8\\code_6.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    demands_normalized = demands / demands.sum()\n    \n    # Calculate the cost of traveling from each node to every other node\n    # Subtracting the normalized demand from the distance gives a heuristic value\n    heuristics = distance_matrix - demands_normalized.unsqueeze(1) - demands_normalized.unsqueeze(0)\n    \n    # Apply swap-insertion heuristic\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                # Check if swap is valid and if the insertion would create a shorter path\n                if (distance_matrix[i, k] + distance_matrix[k, j] < distance_matrix[i, j] and\n                    (distance_matrix[i, k] - distance_matrix[i, j]) + (distance_matrix[k, j] - distance_matrix[i, k]) < 0):\n                    heuristics[i, j] += 1\n                    heuristics[j, i] -= 1\n\n    # Apply 2-opt heuristic\n    for k in range(n):\n        for l in range(n):\n            for m in range(n):\n                for n in range(n):\n                    # Check if 2-opt improvement is possible\n                    if (distance_matrix[k, l] + distance_matrix[l, m] + distance_matrix[m, n] +\n                        distance_matrix[n, k] < distance_matrix[k, l] + distance_matrix[l, n] +\n                        distance_matrix[n, k] + distance_matrix[k, m] + distance_matrix[m, l]):\n                        heuristics[k, l] -= 1\n                        heuristics[l, k] += 1\n                        heuristics[l, m] -= 1\n                        heuristics[m, l] += 1\n                        heuristics[m, n] -= 1\n                        heuristics[n, m] += 1\n                        heuristics[n, k] -= 1\n                        heuristics[k, n] += 1\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Timeout",
      "stdout_file": "coevolve\\generation_8\\stdout_8.txt",
      "code_file": "coevolve\\generation_8\\code_8.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n\n    # Normalize demands by total capacity\n    normalized_demands = demands / total_capacity\n\n    # Calculate the sum of demands along each edge, which is a measure of desirability\n    edge_demand_sums = (normalized_demands[:, None] + normalized_demands[None, :]) * distance_matrix\n\n    # Apply swap-insertion heuristic\n    # Calculate the sum of demands for each pair of customers (including the depot)\n    customer_demand_sums = edge_demand_sums.sum(dim=1)\n    # Apply swap-insertion heuristic: prefer edges that would reduce the maximum demand\n    swap_insertion heuristic = -torch.abs(customer_demand_sums[:, None] - customer_demand_sums[None, :])\n\n    # Apply 2-opt heuristic\n    # Calculate the sum of demands for each cycle\n    cycle_demand_sums = edge_demand_sums.sum(dim=0)\n    # Apply 2-opt heuristic: prefer edges that would reduce the maximum cycle demand\n    two_opt_heuristic = -torch.abs(cycle_demand_sums[:, None] - cycle_demand_sums[None, :])\n\n    # Combine heuristics with real-time penalties to prevent overloading\n    # Introduce a penalty for each edge that would exceed the vehicle capacity\n    over_capacity_penalty = (edge_demand_sums > 1).float() * 1000  # Example penalty\n\n    # Combine all heuristics and penalties\n    combined_heuristic = swap_insertion_heuristic + two_opt_heuristic + over_capacity_penalty\n\n    return combined_heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 8, in <module>\n    from gpt import heuristics_v2 as heuristics\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 18\n    swap_insertion heuristic = -torch.abs(customer_demand_sums[:, None] - customer_demand_sums[None, :])\n                   ^^^^^^^^^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 26, in <module>\n    from CVRPTester import CVRPTester as Tester\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 8, in <module>\n    from CVRPModel import CVRPModel as Model\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 10, in <module>\n    from gpt import heuristics\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 18\n    swap_insertion heuristic = -torch.abs(customer_demand_sums[:, None] - customer_demand_sums[None, :])\n                   ^^^^^^^^^\nSyntaxError: invalid syntax\n",
      "stdout_file": "coevolve\\generation_8\\stdout_9.txt",
      "code_file": "coevolve\\generation_8\\code_9.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    demands_normalized = demands / total_capacity\n\n    # Initialize the heuristics matrix with zeros\n    heuristics = torch.zeros_like(distance_matrix)\n\n    # Calculate the initial heuristics based on normalized demands\n    heuristics += demands_normalized\n\n    # Apply swap-insertion heuristic\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            # Calculate potential improvement if we swap the edges (i, k) and (j, k)\n            # where k is the common node between (i, k) and (j, k)\n            for k in range(1, n):\n                if distance_matrix[i, k] != 0 and distance_matrix[j, k] != 0:\n                    improvement_i = -distance_matrix[i, k] * demands_normalized[k]\n                    improvement_j = -distance_matrix[j, k] * demands_normalized[k]\n                    improvement_swap = (distance_matrix[i, j] - distance_matrix[j, i]) * demands_normalized[k]\n                    potential_improvement = improvement_i + improvement_j + improvement_swap\n\n                    # Update the heuristics if the swap is beneficial\n                    heuristics[i, j] += potential_improvement\n                    heuristics[j, i] += potential_improvement\n\n    # Apply 2-opt heuristic\n    for k in range(1, n):\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                # Calculate the improvement if we reverse the sub-route between i and j\n                improvement = 0\n                for l in range(i, j):\n                    improvement -= distance_matrix[l, l + 1]\n                    improvement += distance_matrix[l + 1, l]\n                improvement *= demands_normalized[k]\n\n                # Update the heuristics if the reversal is beneficial\n                heuristics[i, j] += improvement\n                heuristics[j, i] += improvement\n\n    # Incorporate real-time penalties to prevent overloading\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if distance_matrix[i, j] != 0:\n                # Calculate the penalty based on the potential load of the route\n                potential_load = demands_normalized[i] + demands_normalized[j]\n                if potential_load > 1:\n                    penalty = (potential_load - 1) * 10  # Example penalty factor\n                    heuristics[i, j] -= penalty\n                    heuristics[j, i] -= penalty\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Timeout",
      "stdout_file": "coevolve\\generation_8\\stdout_10.txt",
      "code_file": "coevolve\\generation_8\\code_10.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Normalize demands by the total vehicle capacity\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Initialize the heuristic matrix with zeros\n    heuristics = torch.zeros_like(distance_matrix)\n\n    # Calculate the heuristic values\n    # For simplicity, we use the normalized demand as the heuristic value\n    heuristics = normalized_demands\n\n    # Apply swap-insertion heuristic\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            # Compute the swap heuristic\n            swap_heuristic = heuristics[i] + heuristics[j] - heuristics[i] - heuristics[j]\n            # Update the heuristic matrix for the swapped edges\n            heuristics[i, j] = swap_heuristic\n            heuristics[j, i] = swap_heuristic\n\n    # Apply 2-opt heuristic\n    for k in range(2, n):\n        for i in range(1, n - k + 1):\n            for j in range(i + k, n + 1):\n                # Compute the 2-opt heuristic\n                two_opt_heuristic = heuristics[i, j] - heuristics[i, j - 1] - heuristics[i + 1, j] + heuristics[i, j - 1] + heuristics[i + 1, j - 1]\n                # Update the heuristic matrix for the 2-opt edges\n                heuristics[i, j] = two_opt_heuristic\n                heuristics[i + 1, j] = two_opt_heuristic\n                heuristics[j, i] = two_opt_heuristic\n                heuristics[j, i + 1] = two_opt_heuristic\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 23, in heuristics_v2\n    heuristics[i, j] = swap_heuristic\n    ~~~~~~~~~~^^^^^^\nIndexError: too many indices for tensor of dimension 1\n",
      "stdout_file": "coevolve\\generation_8\\stdout_11.txt",
      "code_file": "coevolve\\generation_8\\code_11.py"
    }
  ]
}