{
  "generation": 10,
  "description": "Develop a state-of-the-art hybrid optimization framework for the Capacitated Vehicle Routing Problem (CVRP) by incorporating a tailored local search module, an adaptive particle swarm optimization (PSO) algorithm with evolving population control, and a dynamic tabu search approach. This framework should emphasize the following pivotal elements to harmonize exploration and exploitation, while ensuring comprehensive search space exploration:\n\n1. **Customized Local Search**: Craft a sophisticated neighborhood exploration process that strictly adheres to vehicle capacity constraints and demand patterns, guaranteeing the generation of feasible and well-balanced neighborhoods.\n\n2. **Advanced PSO with Adaptive Population Dynamics**: Integrate an adaptive PSO algorithm with a dynamic adjustment mechanism for velocity and position update rules. The population management should dynamically adapt to preserve diversity and accelerate convergence towards the optimal solution.\n\n3. **Intelligent Tabu Search with a Flexible Cost Model**: Implement a tabu search mechanism that is capable of adapting to vehicle capacities and demand distributions, enabling the algorithm to navigate intricate solution landscapes and avoid suboptimal traps. The cost function should be highly adaptive, considering both load distribution and routing costs to guide the search process effectively.\n\nThe proposed algorithm should be modular in design, facilitating the isolation and analysis of individual heuristic components. It should prioritize a focused, problem-specific optimization strategy that optimizes load distribution, minimizes routing costs, and enhances overall system performance, while circumventing the drawbacks of static neighborhood structures, ineffective population management, and inflexible tabu list adaptability.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the cumulative sum of demands from the end to the start\n    # This will help us to determine the potential load at each customer\n    cumulative_demands = torch.cumsum(demands[::-1], dim=0)[::-1]\n    \n    # Calculate the potential load at each customer\n    load_at_customers = cumulative_demands - demands\n    \n    # Calculate the potential load at each edge (from depot to customer and customer to customer)\n    # We will use a negative value for the edge from the depot to the first customer\n    edge_loads = torch.cat((load_at_customers, load_at_customers[:-1]), dim=0)\n    \n    # Calculate the heuristic value for each edge\n    # The heuristic is based on the absolute load at the destination customer\n    # We use a negative value for the edge from the depot to the first customer\n    heuristics = -torch.abs(edge_loads)\n    \n    # Normalize the heuristics by the maximum absolute value to ensure they are on the same scale\n    max_abs_value = torch.max(torch.abs(heuristics))\n    if max_abs_value != 0:\n        heuristics /= max_abs_value\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 7, in heuristics_v2\n    demands = demands / total_capacity\n                                      ^\nValueError: step must be greater than zero\n",
      "stdout_file": "coevolve\\generation_10\\stdout_0.txt",
      "code_file": "coevolve\\generation_10\\code_0.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.size(0)\n    demands = demands.to(distance_matrix.dtype)\n    \n    # Calculate the total vehicle capacity\n    total_capacity = demands.sum()\n    \n    # Normalize demands by total capacity\n    normalized_demands = demands / total_capacity\n    \n    # Calculate the heuristic for each edge\n    # The heuristic is defined as the negative sum of the demands of the two nodes\n    # This encourages edges to connect nodes with complementary demands\n    heuristics = -torch.abs(normalized_demands[torch.arange(n)] + normalized_demands[torch.arange(1, n)])\n    \n    # Incorporate distance into the heuristic\n    heuristics += distance_matrix\n    \n    # Adjust the heuristic for the depot node (0) to be less promising\n    # This is done by adding a large negative value to the diagonal of the matrix\n    large_negative = -1e8\n    heuristics[torch.arange(n), torch.arange(n)] += large_negative\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 17, in heuristics_v2\n    # Define a constant for the heuristic to adjust the weight of demand\n                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: The size of tensor a (201) must match the size of tensor b (200) at non-singleton dimension 0\n",
      "stdout_file": "coevolve\\generation_10\\stdout_6.txt",
      "code_file": "coevolve\\generation_10\\code_6.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Ensure the demand vector does not include the depot's demand\n    demands = demands[1:]\n    \n    # Calculate the total vehicle capacity\n    total_capacity = demands.sum()\n    \n    # Normalize customer demands by the total capacity\n    normalized_demands = demands / total_capacity\n    \n    # Calculate the load for each edge as the product of distances and normalized demands\n    load = (distance_matrix * normalized_demands.unsqueeze(1)).squeeze(1)\n    \n    # Define a constant for the heuristic to adjust the weight of demand\n    demand_weight = 0.5\n    \n    # Calculate the heuristic value for each edge as a weighted sum of distance and load\n    heuristic_values = -demand_weight * distance_matrix + (1 - demand_weight) * load\n    \n    return heuristic_values",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 15, in heuristics_v2\n    # Calculate the distance contribution for each edge\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: The size of tensor a (201) must match the size of tensor b (200) at non-singleton dimension 0\n",
      "stdout_file": "coevolve\\generation_10\\stdout_7.txt",
      "code_file": "coevolve\\generation_10\\code_7.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the total vehicle capacity\n    total_capacity = demands.sum()\n    \n    # Normalize demands to represent the fraction of the total capacity each customer requires\n    normalized_demands = demands / total_capacity\n    \n    # Calculate the demand contribution for each edge\n    # We use a simple heuristic where the demand contribution is the normalized demand of the destination node\n    demand_contributions = normalized_demands[1:]  # Exclude the depot node (index 0)\n    \n    # Calculate the distance contribution for each edge\n    # Here we use the distance to the next customer as a proxy for the edge contribution\n    # For the last customer, we set the distance contribution to 0 since it's the end of the route\n    distance_contributions = distance_matrix[1:, 1:]  # Exclude the diagonal and the depot node\n    distance_contributions = distance_contributions.fill_diagonal_(0)\n    \n    # Combine the demand and distance contributions to get the heuristic values\n    # We use a simple linear combination where the weight for demand is 0.5 and for distance is 0.5\n    # This can be adjusted based on the specific problem characteristics\n    heuristic_values = 0.5 * demand_contributions + 0.5 * distance_contributions\n    \n    # Return the heuristic matrix\n    return heuristic_values",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 101, in forward\n    probs = self.decoder(encoded_last_node, state.load, ninf_mask=state.ninf_mask, attention_bias=attention_bias_current_node)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 294, in forward\n    score = score + attention_bias if attention_bias is not None else score\n            ~~~~~~^~~~~~~~~~~~~~~~\nRuntimeError: The size of tensor a (201) must match the size of tensor b (200) at non-singleton dimension 2\n",
      "stdout_file": "coevolve\\generation_10\\stdout_8.txt",
      "code_file": "coevolve\\generation_10\\code_8.py"
    }
  ]
}