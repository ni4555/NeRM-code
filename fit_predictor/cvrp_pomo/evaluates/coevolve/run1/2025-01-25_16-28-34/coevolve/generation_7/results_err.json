{
  "generation": 7,
  "description": "Develop a novel optimization heuristic for the Capacitated Vehicle Routing Problem (CVRP) that integrates a tailored local search with a hybrid evolutionary algorithm. The heuristic shall incorporate the following specific and adaptive components to ensure a focused, dynamic, and effective solution strategy:\n\n1. **Problem-Specific Local Search (PSLS)**: Implement a local search method optimized for CVRP, focusing on neighborhood exploration that respects vehicle capacities and customer demands, aiming to achieve balanced load distribution.\n\n2. **Adaptive Particle Swarm Optimization (APSO)**: Utilize APSO to drive exploration and convergence by dynamically adjusting velocity and position update mechanisms. The adaptive population management strategy will maintain diversity and ensure convergence towards optimal route assignments.\n\n3. **Dynamic Tabu Search with Problem-Specific Cost Function (DTSCF)**: Integrate tabu search with a cost function that dynamically evaluates load balance and distance traveled. This will allow efficient navigation of the solution space, circumventing previously visited suboptimal solutions while actively exploring new regions.\n\nThe proposed heuristic will be designed to ensure the following:\n\n- **Component Distinctiveness**: Each heuristic component will have a clear and unique role in the optimization process, contributing specifically to the resolution of CVRP challenges.\n  \n- **Adaptability and Dynamics**: The heuristics will adapt their behavior based on the problem's current state, allowing for continuous improvement of the search process.\n  \n- **Problem-Specific Details**: The heuristic will address the constraints and characteristics of the CVRP, ensuring that the solution meets the problem's requirements.\n  \n- **Avoid Overgeneralization**: The heuristic will avoid broad, non-specific approaches, focusing on the intricacies of the CVRP to deliver a tailored optimization solution.\n\nThe overall aim is to create a heuristic that achieves optimal load distribution, minimizes routing costs, and provides a clear demonstration of the combined effect of each individual heuristic's contribution to the final solution.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Add a column for the depot demand\n    demands = torch.cat([torch.zeros(1), demands], dim=0)\n\n    # Initialize a matrix of the same shape as distance_matrix with zeros\n    heuristics = torch.zeros_like(distance_matrix)\n\n    # For edges from the depot to customers (i.e., edges to index 1 to n)\n    heuristics[0, 1:] = 1 / distance_matrix[0, 1:] + demands[1:] / (demands.sum() * distance_matrix[0, 1:])\n\n    # For edges between customers (i.e., edges to index 1 to n, excluding the depot)\n    # We do not consider the depot to depot edge, so we start from index 1 and end at index n\n    heuristics[1:, 1:] = 1 / distance_matrix[1:, 1:] + demands[1:] / (demands.sum() * distance_matrix[1:, 1:])\n\n    # The matrix should be symmetric, so fill in the lower triangle\n    heuristics = heuristics + heuristics.t() - torch.diag(torch.diag(heuristics))\n\n    return heuristics\n\n# Example usage:\ndistance_matrix = torch.tensor([[0, 2, 10, 6, 1],\n                                [2, 0, 3, 8, 5],\n                                [10, 3, 0, 7, 4],\n                                [6, 8, 7, 0, 9],\n                                [1, 5, 4, 9, 0]], dtype=torch.float32)\ndemands = torch.tensor([0, 1, 3, 2, 4], dtype=torch.float32)\n\nheuristic_scores = heuristics_v2(distance_matrix, demands)\nprint(heuristic_scores)",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 8, in <module>\n    from gpt import heuristics_v2 as heuristics\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 31, in <module>\n    heuristic_scores = heuristics_v2(distance_matrix, demands)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 12, in heuristics_v2\n    # Calculate the cost to serve each customer from the depot\n                                                     ^^^^^^^^^^\nRuntimeError: The size of tensor a (5) must match the size of tensor b (4) at non-singleton dimension 0\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 26, in <module>\n    from CVRPTester import CVRPTester as Tester\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 8, in <module>\n    from CVRPModel import CVRPModel as Model\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 10, in <module>\n    from gpt import heuristics\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 31, in <module>\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 12, in heuristics_v2\n    # Calculate the cost to serve each customer from the depot\n                                                     ^^^^^^^^^^\nRuntimeError: The size of tensor a (5) must match the size of tensor b (4) at non-singleton dimension 0\n",
      "stdout_file": "coevolve\\generation_7\\stdout_1.txt",
      "code_file": "coevolve\\generation_7\\code_1.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    depot_index = 0\n    demands = demands / demands.sum()  # Normalize demands by total capacity\n\n    # Initialize a tensor with zeros to hold the heuristic values\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n\n    # Calculate the cost to serve each customer from the depot\n    cost_to_depot = distance_matrix[depot_index, 1:]\n\n    # Calculate the heuristic value for each edge ( depot to customer and customer to customer )\n    # Promising edges are those that help in load balancing and minimizing distance\n    # Here, we use a simple heuristic that considers the demand of the customer\n    # and the distance from the depot to the customer\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Calculate heuristic value for edge from i to j\n                edge_heuristic = demands[i] + demands[j] - cost_to_depot[i] - distance_matrix[i, j]\n                heuristic_matrix[i, j] = edge_heuristic\n\n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 23, in heuristics_v2\nIndexError: index 200 is out of bounds for dimension 0 with size 200\n",
      "stdout_file": "coevolve\\generation_7\\stdout_2.txt",
      "code_file": "coevolve\\generation_7\\code_2.py"
    },
    {
      "code": "import torch\nimport numpy as np\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Ensure that the input tensors are on the same device and in the correct shape\n    distance_matrix = distance_matrix.to(demands.device)\n    demands = demands.to(demands.device)\n\n    # Normalize the distance matrix by subtracting the minimum distance for each row (to account for symmetry)\n    min_distance = distance_matrix.min(dim=1, keepdim=True)[0]\n    distance_matrix -= min_distance\n\n    # Normalize demands by dividing by the maximum demand (assuming that demand can be met by at least one vehicle)\n    max_demand = demands.max()\n    demands /= max_demand\n\n    # Calculate a weight for each edge based on the inverse of the distance (to prefer shorter paths)\n    # and the inverse of the demand (to prefer less demanding customers)\n    edge_weights = 1 / (distance_matrix + 1e-10) + 1 / (demands + 1e-10)\n\n    # Sum the weights for each customer, which represents the overall demand for each customer\n    customer_weights = edge_weights.sum(dim=1)\n\n    # Calculate a bonus for customers with a high demand-to-distance ratio\n    # This encourages selecting edges that are close to high-demand customers\n    demand_to_distance_ratio = demands / distance_matrix\n    bonus = 1 / (demand_to_distance_ratio + 1e-10)\n\n    # Combine the weights and the bonus to get the final heuristic values\n    heuristic_values = customer_weights * bonus\n\n    # Clip the values to ensure they are within a certain range to avoid overflow\n    heuristic_values = torch.clamp(heuristic_values, min=-1e8, max=1e8)\n\n    return heuristic_values\n\n# Example usage\ndistance_matrix = torch.tensor([[0, 1, 2, 3], [1, 0, 1, 2], [2, 1, 0, 1], [3, 2, 1, 0]], dtype=torch.float32)\ndemands = torch.tensor([0.1, 0.2, 0.3, 0.4], dtype=torch.float32)\nheuristic_values = heuristics_v2(distance_matrix, demands)\nprint(heuristic_values)",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 52, in pre_forward\n    assert not torch.isnan(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_7\\stdout_7.txt",
      "code_file": "coevolve\\generation_7\\code_7.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    demands_normalized = demands / total_capacity\n\n    # PSLS: Problem-Specific Local Search\n    # Calculate initial heuristics based on distance (the closer, the better)\n    heuristics = -distance_matrix\n\n    # APSO: Adaptive Particle Swarm Optimization\n    # Introduce a particle swarm optimization-inspired heuristic\n    # Here we use a simple heuristic that decreases the heuristic value for closer edges\n    # which is a form of social learning in particle swarms\n    # Note: In a real APSO, this would be more complex, with velocity and position adjustments\n    social_learning_factor = torch.linspace(1, 0.1, steps=n).unsqueeze(0).unsqueeze(1)\n    heuristics += distance_matrix * social_learning_factor\n\n    # DTSCF: Dynamic Tabu Search with Problem-Specific Cost Function\n    # Introduce a cost-based heuristic that penalizes imbalance in vehicle loads\n    # Assuming each vehicle has the same capacity for simplicity\n    vehicle_capacity = 1\n    max_demand_per_vehicle = demands.max()\n    load_imbalance_penalty = (demands - max_demand_per_vehicle).pow(2)\n    load_imbalance_penalty = load_imbalance_penalty.clamp(min=0)  # Remove negative values due to squaring\n\n    # Adjust heuristics based on the expected load imbalance\n    heuristics -= load_imbalance_penalty\n\n    # Combine the PSLS and DTSCF with APSO to finalize the heuristics\n    heuristics = heuristics - demands_normalized.unsqueeze(1)  # Avoid assigning more than one customer to a single edge\n\n    # Return the heuristics\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 19, in heuristics_v2\n    \nRuntimeError: output with shape [201, 201] doesn't match the broadcast shape [1, 201, 201]\n",
      "stdout_file": "coevolve\\generation_7\\stdout_10.txt",
      "code_file": "coevolve\\generation_7\\code_10.py"
    }
  ]
}