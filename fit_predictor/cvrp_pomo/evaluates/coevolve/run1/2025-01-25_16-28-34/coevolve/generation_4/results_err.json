{
  "generation": 4,
  "description": "The goal is to design an efficient optimization heuristic for the Capacitated Vehicle Routing Problem (CVRP) that combines domain-specific insights with simplicity in implementation. The heuristic should prioritize a direct approach using normalized demand and distance as key elements, ensuring clarity and specificity. The heuristic should integrate a basic yet effective local search strategy to refine initial solutions while maintaining an optimal balance between load distribution and distance traveled. This approach will avoid overly complex adaptive mechanisms and will focus on problem context to yield improved system performance, optimal load distribution, and reduced overall routing costs. The new problem description is as follows:\n\n---\n\nDevelop a streamlined heuristic for the Capacitated Vehicle Routing Problem (CVRP) that leverages normalized demand and distance metrics to find an efficient route. The heuristic should initiate by assigning routes based on demand and distance, using a greedy approach to distribute the load evenly across vehicles. Subsequently, employ a simple local search technique to refine the initial solutions, exploring neighboring routes that improve load balance and reduce the total distance traveled. The heuristic should prioritize solutions with a high degree of load uniformity and minimal route deviation, while avoiding unnecessary complexity to ensure quick convergence and practical implementation.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    vehicle_capacity = demands.sum()\n    normalized_demands = demands / vehicle_capacity\n\n    # Greedy assignment based on normalized demand\n    demand_normalized = normalized_demands / normalized_demands.sum()\n    demand_normalized = demand_normalized.view(1, -1)\n    initial_assignment = torch.argmax(distance_matrix * demand_normalized, dim=1)\n\n    # Calculate initial heuristics based on distances and demands\n    heuristics = distance_matrix[torch.arange(n), initial_assignment]\n\n    # Local search to refine the solution\n    for _ in range(10):  # Number of iterations for local search\n        for i in range(1, n):  # Skip the depot node\n            for j in range(1, n):  # Skip the depot node\n                if i != j:\n                    # Swap customers between routes\n                    new_assignment = initial_assignment.clone()\n                    new_assignment[i] = initial_assignment[j]\n                    new_assignment[j] = initial_assignment[i]\n\n                    # Calculate the cost of the new assignment\n                    new_cost = distance_matrix[torch.arange(n), new_assignment].sum()\n\n                    # If the new cost is better, update the assignment\n                    if new_cost < heuristics.sum():\n                        initial_assignment = new_assignment\n                        heuristics = distance_matrix[torch.arange(n), initial_assignment]\n\n    # Normalize heuristics to have a range between 0 and 1\n    heuristics = (heuristics - heuristics.min()) / (heuristics.max() - heuristics.min())\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 99, in forward\n    attention_bias_current_node = self.attention_bias[torch.arange(batch_size)[:, None], state.current_node, :] if IMPL_REEVO else None\n                                  ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: too many indices for tensor of dimension 2\n",
      "stdout_file": "coevolve\\generation_4\\stdout_0.txt",
      "code_file": "coevolve\\generation_4\\code_0.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n    \n    # Initialize the heuristic matrix with high values (undesirable edges)\n    heuristic_matrix = torch.full((n, n), fill_value=1e5)\n    \n    # Greedy assignment based on demand\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                heuristic_matrix[i, j] = -normalized_demands[i] * distance_matrix[i, j]\n    \n    # Add depot to each customer's cost\n    for i in range(1, n):\n        heuristic_matrix[0, i] = -normalized_demands[i] * distance_matrix[0, i]\n    \n    # Local search to refine the solution\n    for _ in range(10):  # Number of iterations for local search\n        for i in range(1, n):\n            for j in range(1, n):\n                if i != j:\n                    for k in range(1, n):\n                        if k != i and k != j:\n                            # Calculate the potential change in the heuristic values\n                            change_i_j = heuristic_matrix[i, j] - heuristic_matrix[i, k]\n                            change_j_k = heuristic_matrix[j, k] - heuristic_matrix[i, k]\n                            if change_i_j > 0 and change_j_k > 0:\n                                # Update the heuristic matrix if the change is positive\n                                heuristic_matrix[i, j] = change_i_j\n                                heuristic_matrix[j, k] = change_j_k\n    \n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Timeout",
      "stdout_file": "coevolve\\generation_4\\stdout_4.txt",
      "code_file": "coevolve\\generation_4\\code_4.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    demand_normalized = demands / total_capacity\n\n    # Greedy assignment based on normalized demand\n    demand_sorted_indices = torch.argsort(demand_normalized)[::-1]\n    greedy_assignment = torch.zeros(n, dtype=torch.int64)\n    load = torch.zeros(n, dtype=torch.float64)\n\n    for i in range(n):\n        # Find the best unassigned customer\n        best_customer = torch.argmax((demand_sorted_indices != i) & (load < 1))\n        greedy_assignment[i] = demand_sorted_indices[best_customer]\n        load[best_customer] += 1\n\n    # Calculate heuristics based on distance and demand\n    heuristics = torch.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(n):\n            if i != j and demand_normalized[i] > 0:\n                heuristics[i, j] = -distance_matrix[i, j]\n\n    # Local search to refine the initial solutions\n    for _ in range(100):  # Number of iterations for local search\n        improved = False\n        for i in range(n):\n            for j in range(n):\n                if i != j and demand_normalized[i] > 0 and heuristics[i, j] > 0:\n                    # Swap customers i and j\n                    temp_demand = demands[i]\n                    demands[i] = demands[j]\n                    demands[j] = temp_demand\n\n                    # Recalculate demand normalization\n                    load = torch.zeros(n, dtype=torch.float64)\n                    for k in range(n):\n                        best_customer = torch.argmax((demand_sorted_indices != k) & (load < 1))\n                        greedy_assignment[k] = demand_sorted_indices[best_customer]\n                        load[demand_sorted_indices[best_customer]] += 1\n\n                    # Calculate new heuristics\n                    new_heuristics = torch.zeros_like(distance_matrix)\n                    for k in range(n):\n                        for l in range(n):\n                            if k != l and demand_normalized[k] > 0:\n                                new_heuristics[k, l] = -distance_matrix[k, l]\n\n                    # Restore original demand if improvement is not found\n                    if new_heuristics[i, j] < heuristics[i, j]:\n                        heuristics = new_heuristics\n                        improved = True\n                    else:\n                        temp_demand = demands[i]\n                        demands[i] = demands[j]\n                        demands[j] = temp_demand\n\n        if not improved:\n            break\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 10, in heuristics_v2\n    normalized_distance_matrix = distance_matrix / distance_matrix.sum(axis=0)\n                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: step must be greater than zero\n",
      "stdout_file": "coevolve\\generation_4\\stdout_6.txt",
      "code_file": "coevolve\\generation_4\\code_6.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    demand_normalized = demands / total_capacity\n    \n    # Calculate normalized distance matrix\n    distance_normalized = distance_matrix / distance_matrix.mean()\n    \n    # Initialize heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Greedy assignment of customers based on normalized demand\n    for i in range(1, n):\n        min_heap = []\n        for j in range(n):\n            if i != j:\n                # Push edge with initial heuristic value (normalized distance)\n                torch.heappush(min_heap, (-distance_normalized[i, j].item(), (i, j)))\n        \n        # Assign the customer to the vehicle with the lowest load\n        while min_heap and demands[torch.tensor(min_heap[0][1][0])] <= total_capacity:\n            _, edge = torch.heappop(min_heap)\n            heuristic_matrix[edge] = demand_normalized[edge[0]] * demand_normalized[edge[1]]\n            total_capacity -= demands[edge[0]]\n    \n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 21, in heuristics_v2\n    \n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\__init__.py\", line 2562, in __getattr__\n    raise AttributeError(f\"module '{__name__}' has no attribute '{name}'\")\nAttributeError: module 'torch' has no attribute 'heappush'\n",
      "stdout_file": "coevolve\\generation_4\\stdout_9.txt",
      "code_file": "coevolve\\generation_4\\code_9.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Greedy assignment based on normalized demand\n    demand_sorted_indices = torch.argsort(normalized_demands)\n    demand_sorted_distances = torch.gather(distance_matrix, 1, demand_sorted_indices.unsqueeze(0))\n\n    # Initialize the heuristic matrix with negative infinity\n    heuristic_matrix = torch.full((n, n), float('-inf'))\n\n    # Set the cost for each customer to its nearest neighbor in the sorted list\n    for i in range(n):\n        if i != 0:  # Skip the depot\n            nearest_neighbor = torch.argmin(demand_sorted_distances[i])\n            heuristic_matrix[i, nearest_neighbor] = distance_matrix[i, nearest_neighbor]\n\n    # Set the cost from the last customer back to the depot\n    heuristic_matrix[torch.arange(1, n), 0] = distance_matrix[torch.arange(1, n), 0]\n\n    # Local search to refine initial solutions\n    for _ in range(n):  # Number of iterations can be tuned\n        improved = False\n        for i in range(n):\n            for j in range(n):\n                if i != j and j != 0 and (i < n - 1 or i == 0):  # Skip the depot\n                    cost_without_i = heuristic_matrix[i, 0] + heuristic_matrix[j, 0]\n                    cost_with_i_j = heuristic_matrix[i, j] + heuristic_matrix[j, 0]\n                    if cost_with_i_j < cost_without_i:\n                        heuristic_matrix[i, j] = cost_with_i_j\n                        improved = True\n        if not improved:\n            break\n\n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 19, in heuristics_v2\n    heuristics[0, i] = normalized_demands[i] * min_distance\n                                        ~~~~~^~~~~~~~~~~~~~~\nIndexError: index 1 is out of bounds for dimension 0 with size 1\n",
      "stdout_file": "coevolve\\generation_4\\stdout_10.txt",
      "code_file": "coevolve\\generation_4\\code_10.py"
    }
  ]
}