{
  "generation": 7,
  "description": "A novel optimization heuristic for the Capacitated Vehicle Routing Problem (CVRP) proposes a hybrid evolutionary algorithm that integrates adaptive genetic operators with enhanced local search techniques. This approach specifically targets the problem scope of finding efficient, capacity-constrained routes for a fleet of vehicles delivering goods to geographically dispersed customers. The heuristic employs a clear problem-solving strategy that leverages the following:\n\n1. A state-of-the-art evolutionary process with adaptive genetic operators, including a selection method based on fitness-probability ranking, an efficient crossover technique with a dynamic recombination rate, and a mutation scheme that selectively alters routes to maintain diversity and prevent premature convergence.\n\n2. Advanced local search heuristics that incorporate a hybrid swap-insertion heuristic and a 2-opt variant optimized for capacity adherence while minimizing route length. These methods are complemented by a real-time penalty system that dynamically adjusts to the evolving population to enforce capacity constraints.\n\n3. A normalization technique that scales customer demand to a common level, ensuring a fair comparison of solutions, and a constraint-aware optimization process that strategically allocates capacities to routes to minimize overloading and maximize efficiency.\n\n4. Adaptive neighborhood and diversity management strategies that adjust the neighborhood structure based on evolutionary progress, employing a feedback mechanism to explore promising regions of the solution space and prevent stagnation in local optima.\n\nThis heuristic guarantees both distance efficiency and capacity adherence, delivering robust and computationally efficient route planning solutions while avoiding the pitfalls of traditional optimization methods.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.size(0)\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Calculate the initial heuristics based on normalized demands\n    initial_heuristics = -normalized_demands.repeat_interleave(n, dim=0) - \\\n                         normalized_demands.repeat(n, 1)\n\n    # Adjust heuristics based on distance (shorter distances should be more desirable)\n    distance_diff = distance_matrix - distance_matrix.mean(dim=1, keepdim=True)\n    distance_diff = torch.abs(distance_diff)\n    adjusted_heuristics = initial_heuristics + distance_diff\n\n    # Apply a penalty for edges leading to overloading\n    overloading_penalty = torch.zeros_like(adjusted_heuristics)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                overloading_penalty[i, j] = 1e-3 * (adjusted_heuristics[i, j] < 0)\n    adjusted_heuristics += overloading_penalty\n\n    return adjusted_heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 10, in heuristics_v2\n    # The heuristic is based on the difference in normalized demand and distance\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: The size of tensor a (40401) must match the size of tensor b (201) at non-singleton dimension 1\n",
      "stdout_file": "coevolve\\generation_7\\stdout_0.txt",
      "code_file": "coevolve\\generation_7\\code_0.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Assuming the total vehicle capacity is the sum of demands (excluding the depot demand)\n    total_capacity = torch.sum(demands)\n    \n    # Normalize customer demands to have a sum of total_capacity\n    normalized_demands = demands / total_capacity\n    \n    # Calculate the demand contribution to the heuristic value\n    demand_contrib = (normalized_demands[1:] - normalized_demands[:-1]) * distance_matrix[1:, :-1]\n    \n    # Calculate the capacity constraint contribution\n    capacity_contrib = torch.clamp(distance_matrix[1:, :-1] / total_capacity, min=0)\n    \n    # Combine both contributions\n    combined_contrib = demand_contrib - capacity_contrib\n    \n    return combined_contrib",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 101, in forward\n    probs = self.decoder(encoded_last_node, state.load, ninf_mask=state.ninf_mask, attention_bias=attention_bias_current_node)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 294, in forward\n    score = score + attention_bias if attention_bias is not None else score\n            ~~~~~~^~~~~~~~~~~~~~~~\nRuntimeError: The size of tensor a (201) must match the size of tensor b (200) at non-singleton dimension 2\n",
      "stdout_file": "coevolve\\generation_7\\stdout_3.txt",
      "code_file": "coevolve\\generation_7\\code_3.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Demand-driven heuristic: Promote edges leading to customers with high demand\n    demand_heuristic = demands[1:] - demands[1:].mean()\n\n    # Distance-driven heuristic: Discourage long edges\n    distance_heuristic = -distance_matrix\n\n    # Normalize both heuristics to the same scale (0 to 1)\n    min_val = distance_heuristic.min()\n    max_val = distance_heuristic.max()\n    distance_heuristic = (distance_heuristic - min_val) / (max_val - min_val)\n    \n    # Combine heuristics: Here we could use any combination strategy. For simplicity, we take the minimum of the two.\n    combined_heuristic = torch.clamp_min(distance_heuristic + demand_heuristic, min=0)\n    \n    # Adjust the heuristic values to ensure some edges are penalized (negative values)\n    # For demonstration purposes, we can just subtract the minimum of combined heuristic from all values\n    adjusted_heuristic = combined_heuristic - combined_heuristic.min()\n    \n    return adjusted_heuristic\n\n# Example usage:\n# n = number of customers (including the depot)\n# Example distance matrix and demands vector:\n# distance_matrix = torch.tensor([[0, 2, 5, 7], [2, 0, 3, 8], [5, 3, 0, 1], [7, 8, 1, 0]])\n# demands = torch.tensor([0, 2, 1, 1])  # 0 for depot, then customer demands\n# heuristics = heuristics_v2(distance_matrix, demands)\n# print(heuristics)",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 17, in heuristics_v2\n    \nRuntimeError: The size of tensor a (201) must match the size of tensor b (200) at non-singleton dimension 1\n",
      "stdout_file": "coevolve\\generation_7\\stdout_10.txt",
      "code_file": "coevolve\\generation_7\\code_10.py"
    }
  ]
}