{
  "generation": 4,
  "description": "The novel heuristic for the Capacitated Vehicle Routing Problem (CVRP) introduces a dynamic, hybrid optimization framework that synergistically employs evolutionary algorithms with advanced local search techniques to achieve robust route planning under stringent capacity constraints. This innovative approach is characterized by the following pivotal elements:\n\n1. **Hybrid Evolutionary Strategy**: The core of the heuristic harnesses a state-of-the-art evolutionary process that incorporates adaptive genetic operators, including a novel selection method based on fitness-probability ranking, a highly efficient crossover technique with a dynamic recombination rate, and a sophisticated mutation scheme that selectively alters candidate routes to maintain diversity and prevent premature convergence.\n\n2. **Enhanced Local Search Heuristics**: The local search component is bolstered by a set of innovative neighborhood exploration methods, including a hybrid swap-insertion heuristic and a 2-opt variant that prioritizes capacity adherence while concurrently optimizing route length. This module leverages a real-time penalty system that dynamically adjusts to the evolving population to ensure that vehicle capacities are not violated.\n\n3. **Advanced Normalization and Constraint Handling**: The heuristic employs a novel normalization technique that scales the demand of customer nodes to a common demand level, enabling a fair comparison of solutions. It further integrates a constraint-aware optimization process that strategically allocates capacities to routes, minimizing the risk of overloading while maximizing route efficiency.\n\n4. **Adaptive Neighborhood and Diversity Management**: The algorithm dynamically adjusts the neighborhood structure based on the evolutionary progress, using a feedback mechanism to identify and exploit promising regions of the solution space. This adaptive diversity management ensures a balanced exploration of the solution landscape, preventing stagnation in local optima.\n\nThis holistic strategy not only guarantees distance efficiency but also maintains strict adherence to vehicle capacity constraints, delivering high-quality solutions that are both robust and computationally efficient. The integration of these advanced techniques provides a comprehensive framework for addressing the complexities of the CVRP, leading to superior route planning outcomes.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Assuming demands are normalized by the total vehicle capacity, we can use them directly.\n    \n    # Calculate the sum of all demands to normalize the distance matrix.\n    total_demand = demands.sum()\n    \n    # Calculate the demand contribution for each edge.\n    # This is the product of the distances and the ratio of the demands of the two nodes.\n    edge_demand_contributions = (distance_matrix * demands.unsqueeze(1) * demands.unsqueeze(0)).sum(dim=2)\n    \n    # Normalize the distance matrix by the sum of all demands to get the relative costs.\n    normalized_distance_matrix = distance_matrix / total_demand\n    \n    # Calculate the heuristic values based on the normalized distances and demand contributions.\n    # Negative values for undesirable edges and positive values for promising ones.\n    heuristics = normalized_distance_matrix - edge_demand_contributions\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 13, in heuristics_v2\n    for i in range(n):\n                       \nIndexError: Dimension out of range (expected to be in range of [-2, 1], but got 2)\n",
      "stdout_file": "coevolve\\generation_4\\stdout_2.txt",
      "code_file": "coevolve\\generation_4\\code_2.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the total vehicle capacity\n    total_capacity = demands.sum()\n    \n    # Normalize demands to the total vehicle capacity\n    normalized_demands = demands / total_capacity\n    \n    # Initialize the heuristics matrix with zeros\n    heuristics = torch.zeros_like(distance_matrix)\n    \n    # Calculate the heuristics based on normalized demands\n    # Here we use a simple heuristic where the attractiveness of an edge is inversely proportional to the demand\n    heuristics = -normalized_demands\n    \n    # Apply a penalty for edges that lead to a higher total demand that exceeds the vehicle capacity\n    # This is a simplistic approach and might need to be adjusted based on the specific problem instance\n    for i in range(distance_matrix.shape[0]):\n        for j in range(distance_matrix.shape[1]):\n            if i != j:  # Skip the depot node\n                # Calculate the total demand if this edge is included\n                total_demand = demands[i] + demands[j]\n                # If the total demand exceeds the capacity, apply a penalty\n                if total_demand > total_capacity:\n                    heuristics[i, j] = -float('inf')\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 99, in forward\n    attention_bias_current_node = self.attention_bias[torch.arange(batch_size)[:, None], state.current_node, :] if IMPL_REEVO else None\n                                  ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: too many indices for tensor of dimension 2\n",
      "stdout_file": "coevolve\\generation_4\\stdout_4.txt",
      "code_file": "coevolve\\generation_4\\code_4.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Initialize a matrix with zeros of the same shape as the distance matrix\n    heuristics_matrix = torch.zeros_like(distance_matrix)\n\n    # Calculate the total vehicle capacity\n    total_capacity = demands.sum()\n\n    # Normalize the demands to the total vehicle capacity\n    normalized_demands = demands / total_capacity\n\n    # Calculate the normalized demand for each customer (excluding the depot)\n    normalized_demands = normalized_demands[1:]\n\n    # Calculate the heuristic values for each edge\n    # For each edge (i, j) with i not equal to j, calculate the heuristic\n    # The heuristic is a function of the distance and normalized demand\n    # Here we use a simple heuristic as an example: -distance + normalized_demand\n    # The negative sign makes shorter distances more desirable\n    for i in range(1, n):  # start from 1 to skip the depot\n        for j in range(1, n):  # start from 1 to skip the depot\n            heuristics_matrix[i, j] = -distance_matrix[i, j] + normalized_demands[i]\n\n    # Return the heuristics matrix\n    return heuristics_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 25, in heuristics_v2\n    return combined_heuristic\n                              \nIndexError: index 200 is out of bounds for dimension 0 with size 200\n",
      "stdout_file": "coevolve\\generation_4\\stdout_9.txt",
      "code_file": "coevolve\\generation_4\\code_9.py"
    }
  ]
}