{
  "generation": 6,
  "description": "This advanced heuristic tackles the Capacitated Vehicle Routing Problem by intertwining an enhanced evolutionary algorithm with an advanced local search routine. Central to our solution is the adaptive evolution process, characterized by:\n\n- An intelligent selection mechanism that fosters solution diversity through fitness-probability ranking.\n- A dynamic crossover scheme that adjusts recombination rates to maintain an optimal balance between exploration and exploitation.\n- A selective mutation method that preserves diversity without compromising vehicle capacities.\n\nOur local search strategy is further fortified with:\n\n- A hybrid swap-insertion heuristic that optimizes route capacities and distances by strategically swapping customer nodes.\n- An innovative 2-opt variant that concurrently shortens routes and adheres to capacity constraints using a real-time penalty system.\n\nEnhancing our approach, we implement a normalization technique to equalize customer demands and a constraint-aware process to maximize efficiency. Furthermore, we adaptively manage the neighborhood and diversity, ensuring comprehensive exploration of the solution space and avoiding local optima traps. This combined approach delivers a robust, efficient framework that optimizes both route efficiency and capacity adherence, outpacing traditional methods in both quality and computational efficiency.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the total vehicle capacity\n    total_capacity = demands.sum()\n    \n    # Normalize the demands to match the vehicle capacity\n    normalized_demands = demands / total_capacity\n    \n    # Calculate the total demand of each edge\n    edge_demands = (normalized_demands[:-1] * normalized_demands[1:]).sum(dim=1)\n    \n    # Calculate the fitness for each edge based on demand and distance\n    # The fitness is negative because we want to maximize the negative value to indicate better edges\n    fitness = -edge_demands\n    \n    # Add some heuristic to penalize long distances\n    # Here we are using a simple linear function for demonstration purposes\n    # The parameter 'distance_penalty' can be adjusted for different heuristics\n    distance_penalty = 0.1\n    fitness -= distance_penalty * distance_matrix\n    \n    # Ensure that the fitness for edges that do not contribute to the solution (self-edges) is set to a very low value\n    # This is done by subtracting the maximum fitness from the fitness values of non-self-edges\n    self_edge_fitness = fitness[self.is_nonzero(distance_matrix, dim=1)]\n    non_self_edge_fitness = fitness[self.is_nonzero(distance_matrix, dim=0)]\n    max_non_self_edge_fitness = non_self_edge_fitness.max()\n    fitness[~self.is_nonzero(distance_matrix, dim=1)] -= max_non_self_edge_fitness\n    \n    return fitness\n\ndef is_nonzero(tensor, dim):\n    # Vectorized way to check if the tensor is non-zero along a given dimension\n    return tensor.ne(0).int().sum(dim=dim) > 0",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 12, in heuristics_v2\n    # Initialize the heuristics matrix with the not_serving_cost\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: Dimension out of range (expected to be in range of [-1, 0], but got 1)\n",
      "stdout_file": "coevolve\\generation_6\\stdout_5.txt",
      "code_file": "coevolve\\generation_6\\code_5.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Calculate the cost of not serving a customer, which is proportional to their demand\n    not_serving_cost = -normalized_demands\n\n    # Initialize the heuristics matrix with the not_serving_cost\n    heuristics = torch.full_like(distance_matrix, fill_value=not_serving_cost)\n\n    # Add a penalty for edges leading from the depot to non-customers\n    for i in range(1, n):\n        heuristics[0, i] = float('inf')\n\n    # Add a penalty for edges leading from non-customers to the depot\n    for i in range(1, n):\n        heuristics[i, 0] = float('inf')\n\n    # Add a penalty for edges between non-adjacent customers\n    for i in range(n):\n        for j in range(n):\n            if i != j and i != 0 and j != 0 and distance_matrix[i, j] != float('inf'):\n                heuristics[i, j] += (abs(i - j) * normalized_demands[i] + normalized_demands[j])\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 13, in heuristics_v2\n    # are more likely to be included in a route, hence we use negative values for distance\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: full_like(): argument 'fill_value' must be Number, not Tensor\n",
      "stdout_file": "coevolve\\generation_6\\stdout_6.txt",
      "code_file": "coevolve\\generation_6\\code_6.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the normalized demand for each customer\n    normalized_demands = demands / demands.sum()\n\n    # Initialize the heuristics matrix with zeros\n    heuristics_matrix = torch.zeros_like(distance_matrix)\n\n    # Calculate the heuristic values using a normalized demand-based method\n    # This is a simple heuristic based on the idea that closer customers with lower demands\n    # are more likely to be included in a route, hence we use negative values for distance\n    # and positive values for demand normalized by total capacity.\n    heuristics_matrix.fill_(distance_matrix.mean())  # Base heuristic\n    heuristics_matrix += normalized_demands  # Adjust based on normalized demand\n\n    # Apply a normalization to ensure all values are within a certain range\n    # We can use Min-Max normalization or any other suitable method\n    min_val = heuristics_matrix.min()\n    max_val = heuristics_matrix.max()\n    heuristics_matrix = (heuristics_matrix - min_val) / (max_val - min_val)\n\n    return heuristics_matrix\n\n# Example usage:\n# Assuming a torch.Tensor for distance_matrix and demands\ndistance_matrix = torch.tensor([\n    [0, 5, 10, 15],\n    [5, 0, 6, 20],\n    [10, 6, 0, 9],\n    [15, 20, 9, 0]\n])\ndemands = torch.tensor([3, 2, 1, 1])\n\n# Get the heuristics\nheuristic_values = heuristics_v2(distance_matrix, demands)\n\nprint(heuristic_values)",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 8, in <module>\n    from gpt import heuristics_v2 as heuristics\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 37, in <module>\n    heuristic_values = heuristics_v2(distance_matrix, demands)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 15, in heuristics_v2\n    heuristics_matrix.fill_(distance_matrix.mean())  # Base heuristic\n                            ^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: mean(): could not infer output dtype. Input dtype must be either a floating point or complex dtype. Got: Long\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 26, in <module>\n    from CVRPTester import CVRPTester as Tester\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 8, in <module>\n    from CVRPModel import CVRPModel as Model\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 10, in <module>\n    from gpt import heuristics\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 37, in <module>\n    heuristic_values = heuristics_v2(distance_matrix, demands)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 15, in heuristics_v2\n    for j in range(i + 1, n):  # only consider edges between customers\n                        ^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: mean(): could not infer output dtype. Input dtype must be either a floating point or complex dtype. Got: Long\n",
      "stdout_file": "coevolve\\generation_6\\stdout_7.txt",
      "code_file": "coevolve\\generation_6\\code_7.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Normalize the demands by the total vehicle capacity\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Initialize the heuristics matrix with high negative values for undesirable edges\n    n = distance_matrix.shape[0]\n    heuristics = torch.full((n, n), -float('inf'))\n\n    # Calculate the initial heuristic values for each edge\n    for i in range(1, n):  # skip the depot node\n        for j in range(i + 1, n):  # only consider edges between customers\n            # Calculate the heuristic value based on the normalized demand and distance\n            heuristics[i, j] = heuristics[j, i] = normalized_demands[i] + normalized_demands[j] - distance_matrix[i, j]\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 53, in pre_forward\n    assert not torch.isinf(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_6\\stdout_8.txt",
      "code_file": "coevolve\\generation_6\\code_8.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the normalized demands\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n\n    # Compute the heuristic values\n    # The heuristic function could be based on the ratio of customer demand to distance\n    # Here we use a simple heuristic where we multiply the normalized demand by the distance\n    # This heuristic is a simple example and may need to be adjusted for a more complex scenario\n    heuristic_matrix = normalized_demands.unsqueeze(1) * distance_matrix.unsqueeze(0)\n\n    # Negative values represent undesirable edges, positive values represent promising ones\n    # In this example, we consider higher demands and shorter distances as more promising\n    # You can adjust the signs or the heuristic function to suit your needs\n\n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 99, in forward\n    attention_bias_current_node = self.attention_bias[torch.arange(batch_size)[:, None], state.current_node, :] if IMPL_REEVO else None\n                                  ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: index 1 is out of bounds for dimension 1 with size 1\n",
      "stdout_file": "coevolve\\generation_6\\stdout_9.txt",
      "code_file": "coevolve\\generation_6\\code_9.py"
    }
  ]
}