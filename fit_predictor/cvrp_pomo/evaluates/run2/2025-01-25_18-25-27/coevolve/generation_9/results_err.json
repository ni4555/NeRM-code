{
  "generation": 9,
  "description": "The new heuristic for the Capacitated Vehicle Routing Problem (CVRP) is designed to address the complexities of capacity-constrained route optimization. This approach merges a state-of-the-art genetic algorithm with a dynamic, neighborhood-based local search technique. Key strategies include:\n\n1. **Hybrid Evolutionary Genetic Algorithm**: Utilizing adaptive genetic operators with a selection method based on fitness-probability ranking, a dynamic recombination rate crossover, and a selective mutation scheme to maintain solution diversity and prevent premature convergence.\n\n2. **Advanced Local Search**: Incorporating a hybrid swap-insertion heuristic and a 2-opt variant that focuses on capacity adherence and route length optimization. This is complemented by a real-time penalty system to prevent overloading while enhancing route efficiency.\n\n3. **Normalization and Constraint Handling**: Implementing a normalization technique for customer demand scaling and a constraint-aware optimization process to allocate capacities, balancing route efficiency and overloading risk.\n\n4. **Adaptive Diversity Management**: Dynamically adjusting neighborhood structures and employing a feedback mechanism to identify and exploit promising solution regions, ensuring balanced exploration of the solution landscape and avoiding local optima stagnation.\n\nThe objective is to optimize route planning for distance efficiency while strictly adhering to vehicle capacity constraints, resulting in computationally efficient, high-quality solutions that are both robust and reliable.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Calculate the initial heuristics based on normalized demands\n    initial_heuristics = normalized_demands * total_capacity\n\n    # Apply a penalty for edges that connect to the depot to avoid starting/ending at the depot\n    depot_penalty = torch.full_like(initial_heuristics, -1e9)\n    initial_heuristics[distance_matrix == 0] = depot_penalty[distance_matrix == 0]\n\n    # Apply a penalty for edges that lead to overloading\n    # Assuming that the maximum capacity is a predefined constant\n    max_capacity = 1.0\n    overloading_penalty = torch.where(\n        initial_heuristics < -max_capacity,\n        torch.full_like(initial_heuristics, -1e9),\n        torch.zeros_like(initial_heuristics)\n    )\n    initial_heuristics += overloading_penalty\n\n    return initial_heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 14, in heuristics_v2\n    \nIndexError: too many indices for tensor of dimension 1\n",
      "stdout_file": "coevolve\\generation_9\\stdout_2.txt",
      "code_file": "coevolve\\generation_9\\code_2.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    demands_sum = demands.sum()\n    normalized_demands = demands / demands_sum\n\n    # Initialize heuristics matrix with zeros\n    heuristics = torch.zeros_like(distance_matrix)\n\n    # Calculate the sum of distances for each edge\n    sum_distances = torch.sum(distance_matrix, dim=1)\n\n    # Calculate the heuristics based on the normalized demands and sum of distances\n    heuristics = normalized_demands.unsqueeze(1) * sum_distances.unsqueeze(0)\n\n    # Adjust heuristics for the depot node (0,0)\n    heuristics[0, 0] = -float('inf')  # Depot to depot is not an edge\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 53, in pre_forward\n    assert not torch.isinf(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_9\\stdout_3.txt",
      "code_file": "coevolve\\generation_9\\code_3.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    demand_normalized = demands / total_capacity\n\n    # Calculate the cost of visiting each customer from the depot\n    cost_to_customer = distance_matrix[0, 1:]\n\n    # Calculate the cost of returning to the depot from each customer\n    cost_from_customer = distance_matrix[1:, 0]\n\n    # Combine the costs to get the total cost for each edge\n    total_cost = cost_to_customer + cost_from_customer\n\n    # Calculate the heuristic value for each edge\n    # The heuristic value is the total cost multiplied by the customer demand\n    # and normalized by the total capacity\n    heuristic_values = total_cost * demand_normalized\n\n    # Invert the heuristic values to have negative values for undesirable edges\n    # and positive values for promising ones\n    heuristics = -heuristic_values\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 21, in heuristics_v2\nRuntimeError: The size of tensor a (200) must match the size of tensor b (201) at non-singleton dimension 0\n",
      "stdout_file": "coevolve\\generation_9\\stdout_6.txt",
      "code_file": "coevolve\\generation_9\\code_6.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Calculate the cost of visiting each customer from the depot\n    visit_cost = distance_matrix[0] * normalized_demands\n\n    # Calculate the heuristic value for each edge\n    heuristics = -visit_cost\n\n    # Apply normalization and constraint handling to adjust the heuristic values\n    # This is a simple normalization step, more complex normalization can be used\n    heuristics = (heuristics - heuristics.min()) / (heuristics.max() - heuristics.min())\n\n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 99, in forward\n    attention_bias_current_node = self.attention_bias[torch.arange(batch_size)[:, None], state.current_node, :] if IMPL_REEVO else None\n                                  ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: too many indices for tensor of dimension 2\n",
      "stdout_file": "coevolve\\generation_9\\stdout_7.txt",
      "code_file": "coevolve\\generation_9\\code_7.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    demands_normalized = demands / demands.sum()\n    \n    # Initialize the heuristic matrix with large negative values\n    heuristics = -torch.ones_like(distance_matrix)\n    \n    # Calculate heuristic based on distance and demand ratio\n    heuristics[distance_matrix != 0] = -distance_matrix[distance_matrix != 0] * demands_normalized[distance_matrix != 0]\n    \n    # Apply a normalization to ensure positive values\n    heuristics = heuristics - heuristics.min()\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 12, in heuristics_v2\n    # We use a simple heuristic here: negative distance + demand\n                                                                 \nIndexError: too many indices for tensor of dimension 1\n",
      "stdout_file": "coevolve\\generation_9\\stdout_9.txt",
      "code_file": "coevolve\\generation_9\\code_9.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    total_capacity = demands[1:].sum()\n    demands_normalized = demands[1:] / total_capacity\n    \n    # Calculate the heuristic for each edge\n    # The heuristic will be a combination of distance and demand\n    # Negative values for undesirable edges, positive for promising ones\n    # We use a simple heuristic here: negative distance + demand\n    # This heuristic assumes that the closer the customer, the more promising the edge is\n    # and the lower the demand, the more promising it is.\n    heuristics = -distance_matrix + demands_normalized\n    \n    # Ensure that the depot (node 0) has a very high heuristic value to avoid being visited\n    heuristics[0] = float('inf')\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 15, in heuristics_v2\n    edge_costs = torch.abs(distance_matrix - distance_matrix.transpose(0, 1))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: The size of tensor a (201) must match the size of tensor b (200) at non-singleton dimension 1\n",
      "stdout_file": "coevolve\\generation_9\\stdout_10.txt",
      "code_file": "coevolve\\generation_9\\code_10.py"
    }
  ]
}