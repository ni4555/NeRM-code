{
  "generation": 6,
  "description": "The task involves the design of an integrated heuristic for solving the Capacitated Vehicle Routing Problem (CVRP) that effectively utilizes prior heuristics while incorporating elements from hybrid evolutionary algorithms. Specifically, the heuristic will leverage local search techniques to explore the neighborhood of solutions, enhance the exploration phase of Particle Swarm Optimization (PSO) through adaptive population management, and employ a dynamic tabu search with an adaptive cost function. The objective is to develop a heuristic that balances load distribution and minimizes routing cost, while ensuring a clear representation of individual heuristic contributions to the overall solution.\n\nThis new heuristic aims to address the limitations of overgeneralization by focusing on the specifics of each component and their integration:\n\n- **Problem-specific Local Search**: Apply local search methods that are tailored to the structure of the CVRP, ensuring efficient neighborhood exploration while considering vehicle capacities and demands.\n  \n- **Adaptive PSO Population Management**: Use PSO to drive exploration by allowing for dynamic adjustment of velocity and position update mechanisms, with an adaptive population management strategy to maintain diversity and convergence towards the optimal route assignments.\n  \n- **Dynamic Tabu Search with Adaptive Cost Function**: Implement tabu search with a cost function that adaptively evaluates both load balance and distance traveled to facilitate efficient navigation of the solution space, avoiding previously visited suboptimal solutions while exploring uncharted regions.\n\nThe proposed heuristic will combine these components in a modular manner, where each heuristic contributes directly to the problem representation, thus avoiding overgeneralization and ensuring a clear, specific, and successful optimization strategy for the CVRP.",
  "solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n\n    # Problem-specific Local Search\n    # Calculate a simple heuristic based on the distance to the depot and the customer demand\n    for i in range(1, n):  # Skip the depot node\n        # Promote edges based on lower distance and demand\n        heuristic_matrix[i, 0] = -distance_matrix[i, 0] - demands[i]\n\n    # Adaptive PSO Population Management\n    # For simplicity, we will use a basic PSO-inspired heuristic that promotes edges closer to the depot\n    # and with lower demand, which could be considered as a \"fitness\" for PSO.\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Promote edges closer to the depot and with lower demand\n                heuristic_matrix[i, j] = -distance_matrix[i, j] - demands[j]\n\n    # Dynamic Tabu Search with Adaptive Cost Function\n    # For simplicity, we will use a tabu list that bans the last used edges\n    # This is a placeholder for a more complex tabu search mechanism\n    tabu_list = set()\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j and (i, j) not in tabu_list:\n                # Increase the heuristic value for edges not in the tabu list\n                heuristic_matrix[i, j] += 1\n\n    return heuristic_matrix",
      "fitness": 23.240375518798828,
      "execution_success": true,
      "error": null,
      "stdout_file": "coevolve\\generation_6\\stdout_1.txt",
      "code_file": "coevolve\\generation_6\\code_1.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Normalize the distance matrix to have a range between 0 and 1\n    normalized_distance_matrix = distance_matrix / torch.max(distance_matrix)\n    \n    # Compute the load factor for each edge\n    load_factor = 2 * demands[:, None] * demands[None, :] / (demands.sum() + 1e-6)\n    \n    # Define a heuristic that combines the normalized distance and load factor\n    # We use a weighted sum of the normalized distance and load factor, where\n    # the weight is set to emphasize the importance of load balancing over distance\n    weight = 0.5\n    heuristic_matrix = -weight * normalized_distance_matrix + (1 - weight) * load_factor\n    \n    return heuristic_matrix",
      "fitness": 23.26895523071289,
      "execution_success": true,
      "error": null,
      "stdout_file": "coevolve\\generation_6\\stdout_11.txt",
      "code_file": "coevolve\\generation_6\\code_11.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the total vehicle capacity (assuming all vehicles have the same capacity)\n    total_capacity = demands.sum()\n    \n    # Normalize customer demands to the range [0, 1]\n    normalized_demands = demands / total_capacity\n    \n    # Initialize a torch tensor with the same shape as distance_matrix, filled with zeros\n    heuristics = torch.zeros_like(distance_matrix)\n    \n    # Example heuristic: Promote edges with lower distance and lower demand difference\n    # The following is a placeholder for the actual heuristic logic\n    heuristics += -distance_matrix  # Lower distances are better, thus negative value\n    heuristics += (1 - torch.abs(normalized_demands.unsqueeze(1) - normalized_demands.unsqueeze(0)))  # Promote edges with similar demands\n    \n    # This is a simple example heuristic, in a real-world scenario you would replace this\n    # with a more complex heuristic that takes into account all the requirements mentioned.\n    \n    return heuristics",
      "fitness": 23.317523956298828,
      "execution_success": true,
      "error": null,
      "stdout_file": "coevolve\\generation_6\\stdout_3.txt",
      "code_file": "coevolve\\generation_6\\code_3.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Problem-specific Local Search: Initialize a promisingness matrix with negative values\n    promisingness_matrix = -torch.ones_like(distance_matrix)\n\n    # Calculate initial load for each customer\n    load = demands.clone()\n\n    # Define a threshold for load imbalance\n    load_threshold = 0.1\n\n    # Initialize a variable to keep track of the maximum load\n    max_load = demands[0]\n\n    # Iterate over all edges to assign them based on load and distance\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Check if adding this customer would cause a significant load imbalance\n                new_load = load[i] + demands[j]\n                load_diff = abs(new_load - load[i])\n\n                # Calculate the distance-based score\n                distance_score = -distance_matrix[i, j]\n\n                # Adjust score based on load\n                if load_diff <= load_threshold * max_load:\n                    load_score = -0.5 * load_diff\n                else:\n                    load_score = -load_diff\n\n                # Update the promisingness matrix\n                promisingness_matrix[i, j] = distance_score + load_score\n\n                # Update the maximum load\n                max_load = max(max_load, new_load)\n\n    return promisingness_matrix",
      "fitness": 23.317523956298828,
      "execution_success": true,
      "error": null,
      "stdout_file": "coevolve\\generation_6\\stdout_4.txt",
      "code_file": "coevolve\\generation_6\\code_4.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Problem-specific Local Search: Calculate the initial heuristic based on demands\n    for i in range(1, n):\n        for j in range(1, n):\n            heuristic_matrix[i, j] = -demands[i]\n    \n    # Adaptive PSO Population Management: Placeholder for PSO exploration\n    # This would involve updating the heuristic_matrix based on PSO dynamics\n    # For the sake of the example, we'll just copy the initial heuristic\n    # In a real implementation, this would be replaced with PSO-driven updates\n    \n    # Dynamic Tabu Search with Adaptive Cost Function: Placeholder for Tabu Search\n    # This would involve further updating the heuristic_matrix based on Tabu Search dynamics\n    # For the sake of the example, we'll just copy the PSO result\n    # In a real implementation, this would be replaced with Tabu Search-driven updates\n    \n    # Combine the results from PSO and Tabu Search (if applicable)\n    # For the sake of the example, we'll just return the initial heuristic\n    # In a real implementation, this would be a combination of the PSO and Tabu Search results\n    \n    return heuristic_matrix",
      "fitness": 23.337182998657227,
      "execution_success": true,
      "error": null,
      "stdout_file": "coevolve\\generation_6\\stdout_2.txt",
      "code_file": "coevolve\\generation_6\\code_2.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Ensure the demands vector is 1-dimensional\n    demands = demands.view(-1)\n    \n    # Initialize the heuristics matrix with zeros\n    heuristics = torch.zeros_like(distance_matrix)\n    \n    # Problem-specific local search heuristic contribution\n    # For simplicity, we'll use a simple heuristic that assumes all edges are promising\n    # and then we'll adjust this based on the demands.\n    heuristics.fill_(1)\n    \n    # Adjust the heuristic values based on the demands (this is where you could implement\n    # more sophisticated logic based on the specifics of the problem and the vehicle capacity)\n    # For now, we just use a simple inverse demand heuristic (demand higher, heuristic lower)\n    # This is just a placeholder and may not be the best heuristic for your problem.\n    heuristics *= (1 / (demands + 1e-6))  # Adding a small constant to avoid division by zero\n    \n    # This is where you would incorporate the other heuristics:\n    # - Adaptive PSO Population Management\n    # - Dynamic Tabu Search with Adaptive Cost Function\n    \n    # Note: The above code does not include the actual PSO or Tabu Search logic,\n    # as these are complex algorithms that would require significant additional code.\n    # The provided code is a starting point that can be expanded upon to include the full\n    # functionality as described in the problem description.\n    \n    return heuristics",
      "fitness": 231.0624542236328,
      "execution_success": true,
      "error": null,
      "stdout_file": "coevolve\\generation_6\\stdout_9.txt",
      "code_file": "coevolve\\generation_6\\code_9.py"
    }
  ]
}