{
  "generation": 6,
  "description": "The task involves the design of an integrated heuristic for solving the Capacitated Vehicle Routing Problem (CVRP) that effectively utilizes prior heuristics while incorporating elements from hybrid evolutionary algorithms. Specifically, the heuristic will leverage local search techniques to explore the neighborhood of solutions, enhance the exploration phase of Particle Swarm Optimization (PSO) through adaptive population management, and employ a dynamic tabu search with an adaptive cost function. The objective is to develop a heuristic that balances load distribution and minimizes routing cost, while ensuring a clear representation of individual heuristic contributions to the overall solution.\n\nThis new heuristic aims to address the limitations of overgeneralization by focusing on the specifics of each component and their integration:\n\n- **Problem-specific Local Search**: Apply local search methods that are tailored to the structure of the CVRP, ensuring efficient neighborhood exploration while considering vehicle capacities and demands.\n  \n- **Adaptive PSO Population Management**: Use PSO to drive exploration by allowing for dynamic adjustment of velocity and position update mechanisms, with an adaptive population management strategy to maintain diversity and convergence towards the optimal route assignments.\n  \n- **Dynamic Tabu Search with Adaptive Cost Function**: Implement tabu search with a cost function that adaptively evaluates both load balance and distance traveled to facilitate efficient navigation of the solution space, avoiding previously visited suboptimal solutions while exploring uncharted regions.\n\nThe proposed heuristic will combine these components in a modular manner, where each heuristic contributes directly to the problem representation, thus avoiding overgeneralization and ensuring a clear, specific, and successful optimization strategy for the CVRP.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the normalized distance matrix\n    normalized_distance_matrix = distance_matrix / torch.max(distance_matrix)\n    \n    # Calculate the cumulative demand matrix\n    cumulative_demand_matrix = torch.cumsum(demands, dim=0)\n    \n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Apply problem-specific local search\n    # Example: Use a simple greedy approach to calculate heuristic values\n    for i in range(1, len(demands) + 1):\n        for j in range(1, i + 1):\n            # Calculate the load after including this edge\n            current_load = cumulative_demand_matrix[j - 1] - cumulative_demand_matrix[i - 1]\n            # Calculate the heuristic value based on load\n            heuristic_matrix[i, j] = -current_load if current_load > 1.0 else normalized_distance_matrix[i, j]\n    \n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 21, in heuristics_v2\n    # Promote edges closer to the depot and with lower demand\n                                                              \nIndexError: index 201 is out of bounds for dimension 0 with size 201\n",
      "stdout_file": "coevolve\\generation_6\\stdout_0.txt",
      "code_file": "coevolve\\generation_6\\code_0.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    \n    # Problem-specific Local Search\n    # Calculate the initial heuristics based on inverse distance (heuristic for nearest neighbor)\n    heuristics = 1 / (distance_matrix ** 2)\n    \n    # Adjust heuristics based on demands to account for customer demand (heuristic for load balancing)\n    demand_weight = demands / demands.sum()\n    heuristics *= demand_weight\n    \n    # Normalize heuristics to ensure they sum up to 1\n    heuristics /= heuristics.sum()\n    \n    # Adaptive PSO Population Management and Dynamic Tabu Search with Adaptive Cost Function\n    # These components would require more complex implementations involving iterative adjustments\n    # and cannot be represented with a single vectorized expression.\n    # Here, we simulate these steps with a placeholder function that would adaptively adjust heuristics.\n    def adapt_heuristics(heuristics):\n        # Placeholder for the adaptive adjustment process\n        # This would involve more complex logic, possibly iterative optimization techniques\n        # For now, we simply add a constant to simulate the adaptive adjustment\n        return heuristics + 0.1\n    \n    heuristics = adapt_heuristics(heuristics)\n    \n    # Ensure that the heuristics are still normalized after adjustment\n    heuristics /= heuristics.sum()\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 52, in pre_forward\n    assert not torch.isnan(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_6\\stdout_5.txt",
      "code_file": "coevolve\\generation_6\\code_5.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    \n    # Problem-specific Local Search: Calculate the total demand to each customer\n    total_demand = torch.sum(demands)\n    demand_potential = demands / total_demand\n    \n    # Adaptive PSO Population Management: Use a simple heuristic based on proximity to the depot\n    # (Here we use a simple inverse distance heuristic, this could be replaced with more complex ones)\n    distance_to_depot = torch.abs(distance_matrix[:, 0])\n    distance_potential = 1 / (distance_to_depot + 1e-8)  # Add a small constant to avoid division by zero\n    \n    # Dynamic Tabu Search with Adaptive Cost Function: Introduce a cost that penalizes high load\n    # Here we use a simple heuristic that considers the difference between max and min demand\n    demand_difference = torch.max(demands) - torch.min(demands)\n    load_potential = -demand_difference  # Negative value to prefer lower load\n    \n    # Combine the heuristics using weights (weights can be adjusted based on problem specifics)\n    alpha, beta, gamma = 0.5, 0.3, 0.2  # Example weights\n    combined_potential = alpha * demand_potential + beta * distance_potential + gamma * load_potential\n    \n    return combined_potential",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 99, in forward\n    attention_bias_current_node = self.attention_bias[torch.arange(batch_size)[:, None], state.current_node, :] if IMPL_REEVO else None\n                                  ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: too many indices for tensor of dimension 2\n",
      "stdout_file": "coevolve\\generation_6\\stdout_6.txt",
      "code_file": "coevolve\\generation_6\\code_6.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    depot_index = 0\n    demands = demands.to(distance_matrix.dtype)\n    distance_matrix = distance_matrix.to(distance_matrix.dtype)\n\n    # Problem-specific Local Search\n    # Calculate the initial heuristic values based on the sum of distances to the depot\n    initial_heuristic = -torch.sum(distance_matrix, dim=1)\n\n    # Adaptive PSO Population Management\n    # For simplicity, we'll use a simple heuristic based on the PSO principle\n    # by considering the inverse of the distance to the depot as a proxy for PSO's fitness\n    # This is a simplified representation and does not reflect a true PSO algorithm\n    pso_heuristic = 1.0 / (distance_matrix[depot_index] + 1e-6)\n\n    # Dynamic Tabu Search with Adaptive Cost Function\n    # Calculate a heuristic based on the total distance to the depot\n    tabu_heuristic = -torch.sum(distance_matrix, dim=1)\n\n    # Combine heuristics with weights to represent their contribution\n    # Note: Weights should be tuned for the specific problem and are chosen arbitrarily here\n    combined_heuristic = 0.5 * (initial_heuristic + pso_heuristic + tabu_heuristic)\n\n    return combined_heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 115, in _test_one_batch\n    selected, _ = self.model(state)\n                  ^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 99, in forward\n    attention_bias_current_node = self.attention_bias[torch.arange(batch_size)[:, None], state.current_node, :] if IMPL_REEVO else None\n                                  ~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: too many indices for tensor of dimension 2\n",
      "stdout_file": "coevolve\\generation_6\\stdout_7.txt",
      "code_file": "coevolve\\generation_6\\code_7.py"
    },
    {
      "code": "import random\nimport torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    # Normalize demands by the total vehicle capacity (assuming demands are normalized)\n    # For this example, we'll use the maximum demand as a proxy for the total capacity\n    total_capacity = demands.max()\n    normalized_demands = demands / total_capacity\n    \n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Apply Problem-specific Local Search\n    # For simplicity, we'll use a basic heuristic that penalizes long distances\n    # and high customer demands. We'll use a linear combination of distance and demand\n    # for the heuristic value.\n    heuristic_matrix += distance_matrix * (1 + normalized_demands)\n    \n    # Apply Adaptive PSO Population Management\n    # PSO-inspired heuristic: We'll add a random component to the heuristic to encourage exploration\n    # The random component will be scaled by the inverse of the distance (to encourage shorter paths)\n    random_component = torch.rand_like(distance_matrix) * (1 / distance_matrix)\n    heuristic_matrix += random_component\n    \n    # Apply Dynamic Tabu Search with Adaptive Cost Function\n    # Tabu-inspired heuristic: We'll add a bonus for paths that haven't been visited recently\n    # We'll simulate this by penalizing paths that have a high correlation with previously visited paths\n    # For simplicity, we'll use a dummy tabu list to represent this\n    tabu_list = torch.zeros_like(distance_matrix)\n    tabu_penalty = torch.abs(tabu_list - 1)\n    heuristic_matrix -= tabu_penalty\n    \n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 53, in pre_forward\n    assert not torch.isinf(self.attention_bias).any()\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
      "stdout_file": "coevolve\\generation_6\\stdout_8.txt",
      "code_file": "coevolve\\generation_6\\code_8.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    n = distance_matrix.shape[0]\n    \n    # Calculate the cost matrix which includes demands\n    cost_matrix = distance_matrix.clone()\n    cost_matrix = torch.cat([cost_matrix, demands.unsqueeze(0)], dim=0)\n    cost_matrix = torch.cat([cost_matrix, torch.zeros(n, 1)], dim=1)\n    cost_matrix = cost_matrix + torch.transpose(cost_matrix, 0, 1)\n    cost_matrix = cost_matrix - torch.diag(torch.diag(cost_matrix))\n    \n    # Calculate the initial heuristic values\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    for i in range(n):\n        for j in range(i+1, n):\n            # Prioritize edges that have lower distance and lower demand difference\n            heuristic_matrix[i, j] = -distance_matrix[i, j] - abs(demands[i] - demands[j])\n    \n    # Apply problem-specific local search to enhance the heuristic values\n    for i in range(n):\n        for j in range(i+1, n):\n            # Example: Improve heuristic by considering vehicle capacity\n            # (This is a placeholder for a more complex local search)\n            heuristic_matrix[i, j] += (demands[i] + demands[j]) / (2 * demands[i])\n    \n    # Normalize the heuristic matrix\n    heuristic_matrix = heuristic_matrix - heuristic_matrix.min()\n    heuristic_matrix = (heuristic_matrix / heuristic_matrix.max()).unsqueeze(0)\n    \n    return heuristic_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 140, in <module>\n    avg_obj = main()\n              ^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_pomo/eval.py\", line 94, in main\n    avg_obj = tester.run()\n              ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 71, in run\n    score, aug_score = self._test_one_batch(batch_size)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPTester.py\", line 109, in _test_one_batch\n    self.model.pre_forward(reset_state)\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 49, in pre_forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\CVRPModel.py\", line 50, in <listcomp>\n    heuristics(distance_matrices[i], all_node_demands[i]) for i in range(all_nodes_xy.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_pomo\\gpt.py\", line 10, in heuristics_v2\n    load_factor = 2 * demands[:, None] * demands[None, :] / (demands.sum() + 1e-6)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: Sizes of tensors must match except in dimension 1. Expected size 202 but got size 201 for tensor number 1 in the list.\n",
      "stdout_file": "coevolve\\generation_6\\stdout_10.txt",
      "code_file": "coevolve\\generation_6\\code_10.py"
    }
  ]
}