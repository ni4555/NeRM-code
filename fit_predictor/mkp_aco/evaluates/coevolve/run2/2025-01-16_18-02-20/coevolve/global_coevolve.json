{
  "generations": [
    {
      "generation": 0,
      "description": "Solving Multiple Knapsack Problems (MKP) through stochastic solution sampling based on \"heuristics\". MKP involves selecting a subset of items to maximize the total prize collected, subject to multi-dimensional maximum weight constraints.",
      "best_fitness": 10.39906567094032,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Calculate the total weight for each item by summing its weights across all dimensions\n    total_weight = np.sum(weight, axis=1)\n    \n    # Normalize the prize by the total weight to get a per-unit-weight prize value\n    normalized_prize = prize / total_weight\n    \n    # Rank the items based on their normalized prize value\n    ranked_indices = np.argsort(normalized_prize)[::-1]\n    \n    # Create an array that indicates how promising it is to include each item\n    heuristics = np.zeros_like(prize)\n    heuristics[ranked_indices] = np.arange(len(ranked_indices))\n    \n    return heuristics"
    },
    {
      "generation": 2,
      "description": "Designing an adaptive stochastic sampling heuristic for solving Multiple Knapsack Problems (MKP) involves selecting a subset of items to maximize the total prize collected, while adhering to multi-dimensional weight constraints. This approach leverages ranking by normalized value and incorporates stochastic sampling to iteratively explore solution spaces. The heuristic employs dynamic weight adjustment and a systematic item selection process to enhance prize maximization and ensure constraint compliance, resulting in an optimized set of items for each knapsack.",
      "best_fitness": 11.024374445264373,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    \n    # Normalize the prize by the sum of the weights for each item\n    normalized_value = prize / weight.sum(axis=1)\n    \n    # Incorporate stochastic sampling to adjust the normalized values\n    # For simplicity, let's use a random perturbation\n    np.random.seed(0)  # Setting a seed for reproducibility\n    random_perturbation = np.random.normal(0, 0.1, normalized_value.shape)\n    adjusted_normalized_value = normalized_value + random_perturbation\n    \n    # Rank the adjusted normalized values\n    rank = np.argsort(-adjusted_normalized_value)  # Descending order\n    \n    # Generate a heuristic score for each item\n    heuristic = np.zeros(n)\n    heuristic[rank] = np.arange(1, n + 1)  # Higher rank, higher score\n    \n    return heuristic"
    },
    {
      "generation": 5,
      "description": "Solve the Multiple Knapsack Problem (MKP) by implementing a probabilistic optimization algorithm. This algorithm will prioritize items based on their value-to-weight ratio and utilize a quantifiable ranking mechanism to maximize the total prize collected. It will employ adaptive stochastic sampling, with criteria defined by the ranking, and dynamically adapt weight constraints iteratively. The process involves selecting a subset of items using a combination of normalized prize value and clear ranking to adhere to each knapsack's strict weight limitations and achieve optimal prize maximization.",
      "best_fitness": 11.363147833510448,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Calculate the value-to-weight ratio for each item\n    value_to_weight_ratio = prize / weight.sum(axis=1)\n    \n    # Normalize the ratios to a 0-1 scale\n    normalized_ratios = (value_to_weight_ratio - value_to_weight_ratio.min()) / (value_to_weight_ratio.max() - value_to_weight_ratio.min())\n    \n    # Rank the items based on the normalized value-to-weight ratio\n    ranked_indices = np.argsort(normalized_ratios)[::-1]\n    \n    # Create the heuristics array where the rank is used as a heuristic value\n    heuristics = np.zeros(len(prize))\n    heuristics[ranked_indices] = np.arange(1, len(ranked_indices) + 1)\n    \n    return heuristics"
    },
    {
      "generation": 9,
      "description": "The MKP is addressed through a hybrid probabilistic optimization heuristic that leverages a dynamic value-to-weight ratio for item prioritization. The algorithm implements a sophisticated ranking mechanism, which employs a normalized value metric to assess item worth per unit weight, thereby ensuring that items with the highest value-to-weight ratio are selected first. This value-centric ranking is integrated with an intelligent stochastic sampling strategy that adapts in real-time to evolving weight constraints during the iterative selection process. The ultimate goal is to maximize the collective prize across all knapsacks while adhering to the stringent weight limits of each knapsack, achieving an optimal balance between exploration and exploitation.",
      "best_fitness": 17.20400961774989,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Calculate the value-to-weight ratio for each item\n    value_to_weight_ratio = prize / weight.sum(axis=1)\n    \n    # Normalize the value-to-weight ratio to ensure it is between 0 and 1\n    max_ratio = np.max(value_to_weight_ratio)\n    normalized_ratio = value_to_weight_ratio / max_ratio\n    \n    # Apply a stochastic sampling strategy based on the normalized ratio\n    # Here we use a simple random sampling with replacement, but this can be replaced\n    # with more sophisticated sampling strategies if needed.\n    random_indices = np.random.choice(range(len(normalized_ratio)), size=len(normalized_ratio), replace=True)\n    sorted_indices = np.argsort(normalized_ratio)[random_indices]\n    \n    # The sorted indices represent the order of item selection based on their normalized value-to-weight ratio\n    heuristics = np.zeros_like(normalized_ratio)\n    heuristics[sorted_indices] = 1\n    \n    return heuristics"
    },
    {
      "generation": 8,
      "description": "Develop an innovative algorithm for tackling the Multiple Knapsack Problem (MKP) that leverages a hybrid approach combining item ranking through optimized value-to-weight ratio normalization, probabilistic item selection, and adaptive sampling mechanisms. The algorithm must emphasize the selection of items with the highest normalized value-to-weight ratio, treating each item's acceptance as a probabilistic event. Furthermore, the algorithm must be capable of dynamically adjusting to evolving weight constraints and iteratively choosing items to maximize the cumulative reward, all while respecting the individual weight limits of each knapsack. This solution aims to enhance the MKP's prize optimization process by mitigating the risks associated with raw ratio reliance and the lack of stochastic item selection.",
      "best_fitness": 17.25715581710777,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Normalize the value-to-weight ratio for each item\n    normalized_ratio = prize / weight.sum(axis=1)\n    \n    # Normalize the ratios to sum to 1\n    normalized_ratio /= normalized_ratio.sum()\n    \n    # Initialize a list to store the heuristics for each item\n    heuristics = np.zeros_like(prize)\n    \n    # Initialize a random number generator\n    rng = np.random.default_rng()\n    \n    # Iterate over each item and assign a heuristic based on the normalized ratio\n    for i in range(prize.shape[0]):\n        # Generate a random number to simulate probabilistic item selection\n        random_number = rng.random()\n        \n        # Calculate the cumulative probability up to the current item\n        cumulative_probability = np.cumsum(normalized_ratio)\n        \n        # Assign the heuristic based on whether the random number falls within the cumulative probability\n        heuristics[i] = 1 if random_number < cumulative_probability[i] else 0\n    \n    return heuristics"
    },
    {
      "generation": 4,
      "description": "Optimize Multiple Knapsack Problems (MKP) by implementing a stochastic solution sampling heuristic that prioritizes items based on their value-to-weight ratio. This approach involves ranking items adaptively, selecting a subset of high-value items using stochastic sampling, and adjusting weight constraints dynamically to maximize total prize collection while respecting individual knapsack weight limits.",
      "best_fitness": 17.27394851011971,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Calculate value-to-weight ratio for each item\n    value_to_weight_ratio = prize / weight.sum(axis=1)\n    \n    # Normalize the ratios to make them comparable across items\n    normalized_ratios = value_to_weight_ratio / value_to_weight_ratio.sum()\n    \n    # Create a binary vector indicating the probability of selection for each item\n    selection_probability = np.random.rand(len(prize))\n    \n    # Sample items based on the normalized ratios\n    item_indices = np.argsort(normalized_ratios)[::-1]\n    selected_item_indices = item_indices[np.random.choice(len(item_indices), size=int(len(prize) / 2), replace=False)]\n    \n    # Initialize the heuristics array with zeros\n    heuristics = np.zeros_like(prize)\n    \n    # Set the heuristics for selected items to 1\n    heuristics[selected_item_indices] = 1\n    \n    return heuristics"
    },
    {
      "generation": 10,
      "description": "Develop a probabilistic algorithm for the Multi-Knapsack Problem (MKP) that leverages a dynamic ranking system to prioritize items with the highest value-to-weight ratio. This system should utilize adaptive stochastic sampling techniques to iteratively select items, optimizing their distribution across knapsacks while rigorously enforcing weight constraints. The algorithm must implement an advanced exploration strategy that systematically identifies and incorporates the most valuable and lightweight items, ensuring optimal load distribution and adherence to individual knapsack weight limits.",
      "best_fitness": 17.483214246508794,
      "best_code": "import numpy as np\nimport numpy as np\nfrom scipy.stats import beta\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n = prize.shape[0]\n    m = weight.shape[1]\n    \n    # Calculate value-to-weight ratio for each item\n    value_to_weight_ratio = prize / weight.sum(axis=1)\n    \n    # Normalize the value-to-weight ratio to a probability distribution\n    normalized_ratio = value_to_weight_ratio / value_to_weight_ratio.sum()\n    \n    # Use Beta distribution to sample probabilities\n    # Alpha and beta parameters can be adjusted to control exploration vs exploitation\n    alpha = 1\n    beta_param = 1\n    \n    # Sample from the Beta distribution\n    heuristics = beta.rvs(alpha + 1, beta_param + 1, size=n)\n    \n    # Normalize to ensure the sum of probabilities is 1\n    heuristics /= heuristics.sum()\n    \n    return heuristics"
    },
    {
      "generation": 6,
      "description": "The heuristic employs a dynamic, multi-dimensional probabilistic model for MKP resolution, integrating advanced normalization techniques with a fine-grained per-unit-weight item ranking system. This refined approach leverages an adaptive stochastic sampling algorithm that optimally selects items based on their value-to-weight ratio, continuously optimizing the total prize under knapsack constraints. The algorithm strategically adjusts sampling parameters in real-time, ensuring a responsive and efficient adaptation to evolving knapsack capacities. Furthermore, it incorporates a state-of-the-art prioritization framework that emphasizes the selection of the most valuable items by weight, thereby significantly enhancing prize accumulation and the overall efficacy of the item selection process.",
      "best_fitness": 18.799006879273502,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Calculate value-to-weight ratio for each item\n    value_to_weight = prize / weight.sum(axis=1)\n    \n    # Normalize the value-to-weight ratio using a dynamic approach\n    normalized_value_to_weight = value_to_weight / value_to_weight.sum()\n    \n    # Initialize the heuristic array\n    heuristics = np.zeros_like(prize)\n    \n    # Prioritize items with the highest normalized value-to-weight ratio\n    sorted_indices = np.argsort(normalized_value_to_weight)[::-1]\n    \n    # Assign heuristic values based on sorted order\n    for i in sorted_indices:\n        heuristics[i] = 1.0\n    \n    return heuristics"
    },
    {
      "generation": 1,
      "description": "Optimizing Multi-dimensional Knapsack Solutions via Adaptive Stochastic Sampling and Advanced Metaheuristics, Incorporating Dynamic Weight Adjustment and Iterative Item Selection for Enhanced Prize Maximization and Constraint Compliance.",
      "best_fitness": 19.210969628663026,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Assuming that the weight constraint is fixed to 1 for each dimension\n    # and that the weight array is shaped (n, m) where m is the dimension.\n    # For simplicity, we assume that the prize array is of shape (n,).\n    # The heuristics function will return the heuristics score for each item.\n    \n    # Calculate the sum of weights for each item, since each dimension's weight is fixed to 1\n    total_weight_per_item = weight.sum(axis=1)\n    \n    # Calculate the prize per unit weight for each item\n    prize_per_weight = prize / total_weight_per_item\n    \n    # Normalize the prize per unit weight to get heuristics values\n    # We use np.clip to prevent division by zero and to keep the values in a reasonable range\n    heuristics = np.clip(prize_per_weight, a_min=0, a_max=1)\n    \n    return heuristics"
    },
    {
      "generation": 7,
      "description": "**Problem Description:**\n\nDesign a probabilistic optimization algorithm for the Multi-Knapsack Problem (MKP) that leverages a dynamic value-to-weight ratio heuristic to prioritize item selection. The algorithm shall employ a novel stochastic sampling technique to iteratively select items for each knapsack, ensuring that weight constraints are dynamically adjusted and refined throughout the optimization process. This approach will aim to maximize the total prize collected while adhering to strict weight limitations. The algorithm should incorporate advanced performance metrics and normalization techniques to enhance its robustness and scalability, enabling efficient solutions for large-scale MKP instances.",
      "best_fitness": 21.504213149884507,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Assuming that the value-to-weight ratio is used for the heuristic\n    # and that the constraint for each dimension is fixed to 1,\n    # the heuristic for each item can be defined as the prize of the item.\n    # Since the prize is the only value to consider and weight is a one-dimensional array\n    # with all elements being 1, the heuristic is simply the prize itself.\n    return prize"
    },
    {
      "generation": 3,
      "description": "Enhancing MKP resolution through a probabilistic optimization algorithm that employs a value-to-weight ratio-driven item prioritization, combined with adaptive stochastic sampling, dynamic weight constraint adaptation, and iterative item selection to maximize overall prize while adhering to each knapsack's strict weight limitations.",
      "best_fitness": 22.07053389229282,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Calculate the value-to-weight ratio for each item\n    value_to_weight_ratio = prize / weight.sum(axis=1)\n    \n    # Normalize the ratios to ensure they sum to 1\n    normalized_ratio = value_to_weight_ratio / value_to_weight_ratio.sum()\n    \n    # Initialize heuristics array with normalized ratios\n    heuristics = np.zeros_like(prize)\n    \n    # Assign higher heuristics values to items with higher ratios\n    heuristics = normalized_ratio\n    \n    return heuristics"
    }
  ]
}