{
  "generation": 5,
  "description": "Design a hybrid optimization heuristic for the Multiple Knapsack Problem (MKP) that incorporates adaptive stochastic sampling. The heuristic should utilize dynamic fitness evaluation and robust perturbation techniques to refine candidate solutions iteratively. This approach will balance exploration and exploitation, ensuring effective prize maximization while respecting stringent weight constraints, and will be supported by a clear metaheuristic framework with well-defined adaptive sampling strategies and perturbation algorithms.",
  "failed_solutions": [
    {
      "code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    heuristic = np.zeros(n)\n    probability = np.zeros(n)\n    \n    # Initialize probability based on prize value\n    probability = prize / np.sum(prize)\n    \n    # Dynamic fitness evaluation\n    for _ in range(100):\n        # Adaptive stochastic sampling\n        selected_indices = np.random.choice(n, size=int(0.1 * n), p=probability)\n        \n        # Robust perturbation techniques\n        for i in selected_indices:\n            new_probability = probability.copy()\n            new_probability[i] = 0\n            # Update the probability for the selected item\n            new_probability /= np.sum(new_probability)\n            \n            # Evaluate new fitness\n            new_fitness = np.dot(new_probability, prize)\n            # Check if the new fitness is better\n            if new_fitness > np.dot(probability, prize):\n                probability = new_probability\n        \n        # Update heuristic based on probability\n        heuristic = probability * 100\n    \n    return heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Filtered by predictor (rank: 2, confidence: 0.9514)",
      "stdout_file": null,
      "code_file": null
    },
    {
      "code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    heuristic = np.zeros(n)\n    probability = np.zeros(n)\n    \n    # Initialize probability based on prize value\n    probability = prize / np.sum(prize)\n    \n    # Adaptive stochastic sampling and dynamic fitness evaluation\n    for _ in range(100):  # Number of iterations can be adjusted for speed optimization\n        new_probability = np.zeros(n)\n        selected_indices = np.random.choice(n, size=int(np.sum(probability)), replace=False, p=probability)\n        \n        for index in selected_indices:\n            if np.all(weight[index] <= 1):\n                heuristic[index] += probability[index]\n                new_probability[index] = probability[index] * (1 + 0.01 * (prize[index] - np.mean(prize)))\n        \n        # Robust perturbation technique\n        perturbation_indices = np.random.choice(n, size=int(0.1 * n), replace=False)\n        for index in perturbation_indices:\n            if np.all(weight[index] <= 1):\n                heuristic[index] -= probability[index] / 10\n        \n        probability = new_probability / np.sum(new_probability)\n    \n    # Normalize heuristic to ensure it is between 0 and 1\n    heuristic /= np.max(heuristic)\n    \n    return heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Filtered by predictor (rank: 3, confidence: 0.7794)",
      "stdout_file": null,
      "code_file": null
    },
    {
      "code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    # Initialize heuristic values to 0\n    heuristics = np.zeros(n)\n    \n    # Define adaptive sampling and perturbation parameters\n    alpha = 0.1  # Exploration rate\n    beta = 0.9   # Exploitation rate\n    \n    # Define the number of iterations for dynamic fitness evaluation\n    iterations = 100\n    \n    for _ in range(iterations):\n        # Adaptive stochastic sampling\n        random_index = np.random.randint(n)\n        sample_heuristics = heuristics + np.random.normal(0, alpha)\n        \n        # Dynamic fitness evaluation\n        current_fitness = np.dot(sample_heuristics, prize)\n        \n        # Robust perturbation\n        for i in range(n):\n            if weight[i].sum() <= 1:\n                perturbation = np.random.choice([1, -1], p=[beta, 1 - beta])\n                new_heuristics = sample_heuristics.copy()\n                new_heuristics[i] += perturbation\n                new_fitness = np.dot(new_heuristics, prize)\n                \n                if new_fitness > current_fitness:\n                    sample_heuristics = new_heuristics\n                    current_fitness = new_fitness\n        \n        # Update heuristics based on the best perturbation\n        heuristics = sample_heuristics\n    \n    return heuristics",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Filtered by predictor (rank: 4, confidence: 0.1208)",
      "stdout_file": null,
      "code_file": null
    },
    {
      "code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    fitness = np.zeros(n)\n    heuristic = np.zeros(n)\n    max_prize = np.max(prize)\n    min_weight = np.min(weight)\n    max_weight = np.max(weight)\n    \n    # Adaptive Stochastic Sampling\n    for i in range(n):\n        # Dynamic fitness evaluation\n        for j in range(m):\n            if weight[i, j] < min_weight or weight[i, j] > max_weight:\n                fitness[i] += prize[i] * (1 - weight[i, j] / max_weight)\n            else:\n                fitness[i] += prize[i] * (1 - weight[i, j] / min_weight)\n        \n        # Robust perturbation techniques\n        if np.random.rand() < 0.1:  # 10% chance to apply perturbation\n            if np.random.rand() < 0.5:\n                perturbation = np.random.uniform(-0.1, 0.1)\n                fitness[i] = max(0, min(fitness[i] + perturbation, max_prize))\n            else:\n                perturbation = np.random.uniform(0.1, 0.5)\n                fitness[i] = min(max_prize, fitness[i] + perturbation)\n        \n        # Update heuristic based on dynamic fitness\n        heuristic[i] = fitness[i] / max(fitness)\n    \n    return heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"E:\\Projects\\CO\\reevo-main/problems/mkp_aco/eval.py\", line 58, in <module>\n    obj = solve(prize, weight)\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"E:\\Projects\\CO\\reevo-main/problems/mkp_aco/eval.py\", line 27, in solve\n    obj, _ = aco.run(N_ITERATIONS)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Anaconda3\\envs\\reevo\\Lib\\site-packages\\torch\\utils\\_contextlib.py\", line 116, in decorate_context\n    return func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"E:\\Projects\\CO\\reevo-main\\problems\\mkp_aco\\aco.py\", line 50, in run\n    sols = self.gen_sol() # (n_ants, max_horizon)\n           ^^^^^^^^^^^^^^\n  File \"E:\\Projects\\CO\\reevo-main\\problems\\mkp_aco\\aco.py\", line 92, in gen_sol\n    items = self.pick_item(mask, dummy_mask)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"E:\\Projects\\CO\\reevo-main\\problems\\mkp_aco\\aco.py\", line 103, in pick_item\n    dist = Categorical(dist)\n           ^^^^^^^^^^^^^^^^^\n  File \"D:\\Anaconda3\\envs\\reevo\\Lib\\site-packages\\torch\\distributions\\categorical.py\", line 72, in __init__\n    super().__init__(batch_shape, validate_args=validate_args)\n  File \"D:\\Anaconda3\\envs\\reevo\\Lib\\site-packages\\torch\\distributions\\distribution.py\", line 71, in __init__\n    raise ValueError(\nValueError: Expected parameter probs (Tensor of shape (10, 101)) of distribution Categorical(probs: torch.Size([10, 101])) to satisfy the constraint Simplex(), but found invalid values:\ntensor([[nan, nan, nan,  ..., nan, nan, nan],\n        [nan, nan, nan,  ..., nan, nan, nan],\n        [nan, nan, nan,  ..., nan, nan, nan],\n        ...,\n        [nan, nan, nan,  ..., nan, nan, nan],\n        [nan, nan, nan,  ..., nan, nan, nan],\n        [nan, nan, nan,  ..., nan, nan, nan]], dtype=torch.float64)\n",
      "stdout_file": "coevolve\\generation_5\\stdout_2.txt",
      "code_file": "coevolve\\generation_5\\code_2.py"
    }
  ]
}