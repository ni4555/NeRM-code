{
  "generations": [
    {
      "generation": 5,
      "description": "The objective is to develop a robust optimization algorithm for the Multiple Knapsack Problem (MKP), which involves selecting item subsets to maximize total prize collection while adhering to strict multi-dimensional weight constraints. The algorithm should incorporate a dynamic adaptive weight allocation mechanism to efficiently partition knapsacks, and utilize a refined heuristic-based sampling strategy to ensure precise subset selection. This approach aims to enhance problem-solving efficiency by focusing on the dynamics of the MKP, promoting diversity in solutions, and applying normalization techniques to optimize the allocation process.",
      "best_fitness": 18.554145943681814,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    m = weight.shape[1]\n    normalized_weight = weight / weight.sum(axis=1, keepdims=True)\n    utility = prize / normalized_weight.sum(axis=1, keepdims=True)\n    max_utility = utility.max(axis=1)\n    return max_utility"
    },
    {
      "generation": 3,
      "description": "Enhancing MKP resolution through a refined hybrid metaheuristic framework, we emphasize integrated adaptive weight allocation for dynamic knapsack partitioning, coupled with a strategically enhanced heuristic-based sampling mechanism, to precisely refine subset selection, ultimately maximizing reward gains while rigorously maintaining capacity constraints.",
      "best_fitness": 20.405178996337053,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    # Calculate the total capacity for the knapsack\n    total_capacity = np.sum(weight, axis=1)\n    # Initialize heuristic values\n    heuristics = np.zeros(n)\n    # Loop over each item\n    for i in range(n):\n        # Calculate the reward to weight ratio for the current item\n        reward_to_weight_ratio = prize[i] / total_capacity[i]\n        # Calculate the contribution of the item to the overall diversity\n        diversity_contribution = np.abs(np.sum(weight[:, :i]) - np.sum(weight[:, i+1:]))\n        # Update the heuristic value based on the reward-to-weight ratio and diversity\n        heuristics[i] = reward_to_weight_ratio + diversity_contribution\n    # Normalize the heuristic values to ensure they sum to the total capacity\n    heuristics /= np.sum(heuristics)\n    return heuristics"
    },
    {
      "generation": 4,
      "description": "Optimizing the selection of diverse items for a multi-knapsack scenario through a hybrid metaheuristic approach that incorporates adaptive weighting and dynamic partitioning strategies. This approach leverages a stochastic sampling mechanism to strategically select subsets of items, maximizing the reward-to-weight ratio while adhering to multi-dimensional weight constraints and ensuring optimal item diversity and normalization.",
      "best_fitness": 20.4354570062635,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    # Initialize a matrix to store the ratio of prize to weight for each item in each dimension\n    prize_weight_ratio = np.zeros((n, m))\n    for i in range(n):\n        prize_weight_ratio[i] = prize[i] / weight[i]\n    \n    # Calculate the average ratio for each dimension\n    avg_ratio = np.mean(prize_weight_ratio, axis=0)\n    \n    # Calculate the normalized ratio for each item in each dimension\n    normalized_ratio = prize_weight_ratio / avg_ratio\n    \n    # Perform a stochastic sampling to select subsets of items\n    random_indices = np.random.choice(n, size=n, replace=False)\n    \n    # Calculate the heuristics for each item based on normalized ratio\n    heuristics = np.zeros(n)\n    for i in range(n):\n        heuristics[random_indices[i]] = np.sum(normalized_ratio[random_indices[i]])\n    \n    return heuristics"
    },
    {
      "generation": 9,
      "description": "The objective is to devise a sophisticated optimization algorithm for the Multiple Knapsack Problem (MKP) that achieves maximum prize collection through a dynamic allocation of item subsets, constrained by multi-dimensional weight limits. The algorithm shall incorporate a self-adaptive weight distribution system to enhance partitioning efficiency, and apply a precision-based heuristic sampling method for targeted subset selection. The approach will focus on leveraging the evolving nature of the MKP to foster solution diversity, and implement normalization techniques to fine-tune the weight allocation process, ensuring a balanced and efficient optimization strategy.",
      "best_fitness": 21.600028294926318,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Calculate the sum of prizes for normalization\n    total_prize = np.sum(prize)\n    # Normalize the prizes and weights\n    normalized_prize = prize / total_prize\n    normalized_weight = weight / np.sum(weight, axis=1, keepdims=True)\n    \n    # Initialize heuristic scores\n    heuristics = np.zeros_like(prize)\n    \n    # Calculate heuristic scores\n    for i in range(prize.shape[0]):\n        for j in range(weight.shape[1]):\n            heuristics[i] += normalized_prize[i] * normalized_weight[i, j]\n    \n    return heuristics"
    },
    {
      "generation": 8,
      "description": "The task is to devise an optimized heuristic algorithm for solving the Multiple Knapsack Problem (MKP). The algorithm must dynamically adapt item weights in real-time to optimize multi-dimensional constraints, while ensuring the efficient partitioning of knapsacks. It should implement a sophisticated heuristic-based sampling technique to selectively sample item subsets for maximized prize collection. The algorithm must prioritize solution diversity to avoid local optima and integrate normalization techniques to enhance utility calculations, leading to an improved total prize collection while adhering to weight constraints.",
      "best_fitness": 21.672541706750003,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    \n    # Calculate the utility of each item as the normalized prize value\n    utility = prize / np.sum(prize)\n    \n    # Calculate the load of each item in each dimension\n    load = weight / np.sum(weight, axis=1, keepdims=True)\n    \n    # Initialize a matrix to store the heuristic value for each item in each dimension\n    heuristic_matrix = np.zeros((n, m))\n    \n    # Calculate the heuristic for each item in each dimension\n    for i in range(n):\n        for j in range(m):\n            # Calculate the heuristic value based on the load and utility\n            heuristic_matrix[i, j] = load[i, j] * utility[i]\n    \n    # Sum the heuristic values across dimensions to get the final heuristic for each item\n    final_heuristic = np.sum(heuristic_matrix, axis=1)\n    \n    # Apply a selection heuristic to prioritize diverse solutions\n    selected_indices = np.argsort(final_heuristic)[-n//2:]  # Select top n//2 items for diversity\n    final_heuristic[selected_indices] = 1.5 * final_heuristic[selected_indices]  # Increase their heuristic value\n    \n    return final_heuristic"
    },
    {
      "generation": 0,
      "description": "Solving Multiple Knapsack Problems (MKP) through stochastic solution sampling based on \"heuristics\". MKP involves selecting a subset of items to maximize the total prize collected, subject to multi-dimensional maximum weight constraints.",
      "best_fitness": Infinity,
      "best_code": ""
    }
  ]
}