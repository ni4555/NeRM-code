{
  "generations": [
    {
      "generation": 9,
      "description": "Optimizing a multi-dimensional knapsack selection process by incorporating an adaptive metaheuristic exploration strategy. This strategy dynamically balances exploration and exploitation, focusing on high-value item combinations while ensuring compliance with dimension-specific weight limits. The algorithm leverages an adaptive mechanism to prioritize valuable subsets and adjusts heuristics in real-time to prevent local optima, ultimately enhancing overall performance in the presence of stringent weight constraints.",
      "best_fitness": -21.742557164384937,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    heuristic = np.zeros(n)\n    \n    # Calculate heuristic based on the weighted sum of prizes and weights\n    for i in range(n):\n        total_prize = 0\n        total_weight = 0\n        for j in range(m):\n            total_prize += prize[i] * weight[i, j]\n            total_weight += weight[i, j]\n        # Normalize by weight to get a per-item heuristic\n        heuristic[i] = total_prize / total_weight if total_weight != 0 else 0\n    \n    # Adjust heuristics to balance exploration and exploitation\n    # Here, we can use a simple method like penalizing high weights\n    for i in range(n):\n        heuristic[i] = heuristic[i] / (1 + weight[i].sum())\n    \n    return heuristic"
    },
    {
      "generation": 3,
      "description": "Optimizing the selection of item subsets in a multi-dimensional knapsack problem by integrating adaptive metaheuristic-based stochastic sampling. This approach aims to maximize combined reward through enhanced exploration of the solution space, balancing exploitation and exploration while respecting stringent weight limits. The algorithm prioritizes high-value item combinations and dynamically adjusts heuristics to ensure compliance with dimension-specific weight constraints, mitigating the risk of local optima and improving overall performance.",
      "best_fitness": -20.179418703822698,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    n, m = prize.shape[0], weight.shape[1]\n    heuristic = np.dot(prize, np.sum(weight, axis=1)) / np.sum(weight**2, axis=1)\n    return heuristic"
    },
    {
      "generation": 8,
      "description": "Developing an advanced multi-dimensional knapsack solver with a robust hybrid metaheuristic-driven stochastic optimization engine for selecting optimal item combinations. This solver incorporates an adaptive dynamic heuristic adjustment mechanism to maximize cumulative rewards while adhering to strict weight boundaries. The core algorithm emphasizes an equilibrium between exploration and exploitation to avoid convergence to suboptimal solutions, ensuring strict adherence to individual dimension weight constraints and achieving peak performance in identifying the most valuable subsets of items.",
      "best_fitness": -18.328544318213183,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Initialize the heuristic array with zeros\n    n = prize.shape[0]\n    heuristics = np.zeros(n)\n    \n    # Calculate the total weight capacity\n    total_weight_capacity = np.sum(weight, axis=1)\n    \n    # Initialize a matrix to store cumulative rewards\n    cumulative_rewards = np.zeros((n, n))\n    \n    # Calculate cumulative rewards for each item\n    for i in range(n):\n        cumulative_rewards[i, i] = prize[i]\n        for j in range(i + 1, n):\n            cumulative_rewards[i, j] = prize[i] + prize[j]\n    \n    # Initialize a matrix to store cumulative weights\n    cumulative_weights = np.zeros((n, n))\n    \n    # Calculate cumulative weights for each item\n    for i in range(n):\n        cumulative_weights[i, i] = weight[i, 0]\n        for j in range(i + 1, n):\n            cumulative_weights[i, j] = weight[i, 0] + weight[j, 0]\n    \n    # Initialize a matrix to store heuristic values\n    heuristic_matrix = np.zeros((n, n))\n    \n    # Calculate heuristic values\n    for i in range(n):\n        for j in range(i + 1, n):\n            heuristic_matrix[i, j] = cumulative_rewards[i, j] / cumulative_weights[i, j]\n    \n    # Apply adaptive dynamic heuristic adjustment\n    for i in range(n):\n        for j in range(i + 1, n):\n            if heuristic_matrix[i, j] > heuristics[i]:\n                heuristics[i] = heuristic_matrix[i, j]\n            if heuristic_matrix[i, j] > heuristics[j]:\n                heuristics[j] = heuristic_matrix[i, j]\n    \n    return heuristics"
    },
    {
      "generation": 1,
      "description": "Optimizing the selection of diverse item subsets for maximizing combined reward in Multi-dimensional Knapsack Problems through adaptive heuristic-based stochastic solution sampling. This approach integrates advanced combinatorial optimization techniques, incorporating metaheuristics for enhanced exploration of the solution space, while ensuring adherence to stringent multi-dimensional weight limits and prioritizing high-value item combinations for optimal prize accumulation.",
      "best_fitness": -16.511647549988858,
      "best_code": "import numpy as np\nimport numpy as np\n\ndef heuristics_v2(prize: np.ndarray, weight: np.ndarray) -> np.ndarray:\n    # Initialize the heuristics array with zeros\n    heuristics = np.zeros_like(prize)\n    \n    # Calculate the total weight for each dimension\n    total_weight = np.sum(weight, axis=0)\n    \n    # Calculate the cumulative prize and weight for each item\n    cumulative_prize = np.zeros_like(prize)\n    cumulative_weight = np.zeros_like(prize)\n    cumulative_prize[0] = prize[0]\n    cumulative_weight[0] = weight[0, 0]\n    \n    for i in range(1, len(prize)):\n        cumulative_prize[i] = cumulative_prize[i-1] + prize[i]\n        cumulative_weight[i] = cumulative_weight[i-1] + weight[i, 0]\n    \n    # Iterate over each item and calculate the heuristics value\n    for i in range(len(prize)):\n        for j in range(i+1, len(prize)):\n            # Check if adding the next item would exceed the weight limit\n            if cumulative_weight[j] <= total_weight[0]:\n                # Calculate the heuristic value as the difference in prize\n                heuristics[i] = max(heuristics[i], cumulative_prize[j] - cumulative_prize[i])\n    \n    return heuristics"
    },
    {
      "generation": 0,
      "description": "Solving Multiple Knapsack Problems (MKP) through stochastic solution sampling based on \"heuristics\". MKP involves selecting a subset of items to maximize the total prize collected, subject to multi-dimensional maximum weight constraints.",
      "best_fitness": Infinity,
      "best_code": ""
    }
  ]
}