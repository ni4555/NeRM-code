{
  "generation": 9,
  "description": "Develop a heuristic algorithm for the Capacitated Vehicle Routing Problem (CVRP) that prioritizes shortest travel distance while accommodating diverse customer demands and adhering strictly to vehicle capacity limits. Utilize a normalized demand-based approach and integrate a negative weighted distance strategy to streamline the solution process. The algorithm should be designed to simplify the mathematical complexity, ensuring a clear and concise heuristic structure. Emphasize optimization techniques such as dynamic load balancing and proximity-based route planning to enhance operational efficiency. The heuristic must be robust, adaptable, and capable of delivering significant performance improvements with minimal complexity, avoiding the integration of complex multi-objective evolutionary algorithms.",
  "failed_solutions": [
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Get the size of the matrix\n    n = distance_matrix.size(0)\n    \n    # Normalize demands\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n    \n    # Create a matrix for normalized demand-based heuristic\n    demand_based_heuristic = torch.zeros_like(distance_matrix)\n    \n    # Calculate negative demand-based heuristic\n    for i in range(1, n):  # Exclude the depot\n        for j in range(1, n):  # Exclude the depot\n            demand_based_heuristic[i][j] = -normalized_demands[i] * normalized_demands[j]\n    \n    # Create a matrix for negative weighted distance heuristic\n    distance_based_heuristic = -distance_matrix\n    \n    # Combine the two heuristics\n    combined_heuristic = demand_based_heuristic + distance_based_heuristic\n    \n    # Introduce a slight perturbation to ensure the algorithm doesn't always pick the shortest paths\n    combined_heuristic = combined_heuristic + torch.randn_like(combined_heuristic) * 0.1\n    \n    # Set the diagonal to negative infinity as no self-loops are desired\n    torch.fill_diagonal_indices(combined_heuristic, float('-inf'))\n    \n    return combined_heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 164, in <module>\n    score_optimal, score_student, gap = main_test()\n                                        ^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 105, in main_test\n    score_optimal, score_student, gap = tester.run()\n                                        ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 73, in run\n    score_teacher, score_student, problems_size = self._test_one_batch(\n                                                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 185, in _test_one_batch\n    self.model(state, self.env.selected_node_list, self.env.solution, current_step,\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 92, in forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 93, in <listcomp>\n    heuristics(distance_matrices[i], demands[i]) for i in range(distance_matrices.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\gpt.py\", line 30, in heuristics_v2\n    # We add a term that balances the load across the edges\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\__init__.py\", line 2562, in __getattr__\n    raise AttributeError(f\"module '{__name__}' has no attribute '{name}'\")\nAttributeError: module 'torch' has no attribute 'fill_diagonal_indices'\n",
      "stdout_file": "coevolve\\generation_9\\stdout_2.txt",
      "code_file": "coevolve\\generation_9\\code_2.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Ensure that the demands are normalized by the total vehicle capacity\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Calculate the negative weighted distance matrix\n    # We use negative values to indicate shorter distances as more promising\n    negative_distance_matrix = -distance_matrix\n\n    # Integrate demand-based prioritization\n    # We add a term that prioritizes edges with lower demand\n    demand_weighted_matrix = negative_distance_matrix + normalized_demands.unsqueeze(1) * demands.unsqueeze(0)\n\n    # Integrate proximity-based route planning\n    # We add a term that prioritizes edges closer to the depot\n    depot_index = 0\n    distance_to_depot = torch.zeros_like(distance_matrix)\n    distance_to_depot.fill_(float('inf'))\n    distance_to_depot[depot_index] = 0\n    for i in range(len(distance_matrix)):\n        for j in range(len(distance_matrix[i])):\n            distance_to_depot[j] = torch.min(distance_to_depot[j], distance_to_depot[i] + distance_matrix[i][j])\n    distance_to_depot = -distance_to_depot\n    proximity_weighted_matrix = demand_weighted_matrix + distance_to_depot.unsqueeze(1) * distance_to_depot.unsqueeze(0)\n\n    # Dynamic load balancing\n    # We add a term that balances the load across the edges\n    load_balance_matrix = proximity_weighted_matrix.clone()\n    for i in range(len(distance_matrix)):\n        for j in range(len(distance_matrix[i])):\n            load_balance_matrix[i][j] += (demands[i] - demands[j]) * (demands[i] - demands[j])\n\n    return load_balance_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 164, in <module>\n    score_optimal, score_student, gap = main_test()\n                                        ^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 105, in main_test\n    score_optimal, score_student, gap = tester.run()\n                                        ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 73, in run\n    score_teacher, score_student, problems_size = self._test_one_batch(\n                                                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 185, in _test_one_batch\n    self.model(state, self.env.selected_node_list, self.env.solution, current_step,\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 102, in forward\n    probs = self.decoder(self.encoded_nodes, selected_node_list,self.capacity, remaining_capacity, attention_bias=self.attention_bias)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 300, in forward\n    out[:, 1:-1] += attention_bias_current_node_unselect[:, :, None]  # shape: (B, V-current_step, 2)\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: The size of tensor a (2) must match the size of tensor b (201) at non-singleton dimension 3\n",
      "stdout_file": "coevolve\\generation_9\\stdout_3.txt",
      "code_file": "coevolve\\generation_9\\code_3.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Normalize demands\n    demand_sum = demands.sum()\n    normalized_demands = demands / demand_sum\n\n    # Calculate the negative weighted distance based on demand\n    negative_weighted_distance = -distance_matrix * normalized_demands.unsqueeze(1) * normalized_demands.unsqueeze(0)\n\n    # Use dynamic load balancing to adjust negative weighted distance\n    # Sort the distances by absolute value (to simulate load balancing)\n    sorted_indices = torch.argsort(torch.abs(negative_weighted_distance), dim=1)\n    negative_weighted_distance = negative_weighted_distance.index_select(1, sorted_indices)\n\n    # Proximity-based route planning to enhance the heuristic\n    # Increase the negative weight of distances to more distant customers\n    proximity_factor = 1 / (distance_matrix.sum(dim=0) + 1e-6)\n    negative_weighted_distance *= proximity_factor.unsqueeze(0)\n\n    return negative_weighted_distance",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 164, in <module>\n    score_optimal, score_student, gap = main_test()\n                                        ^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 105, in main_test\n    score_optimal, score_student, gap = tester.run()\n                                        ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 73, in run\n    score_teacher, score_student, problems_size = self._test_one_batch(\n                                                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 185, in _test_one_batch\n    self.model(state, self.env.selected_node_list, self.env.solution, current_step,\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 92, in forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 93, in <listcomp>\n    heuristics(distance_matrices[i], demands[i]) for i in range(distance_matrices.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\gpt.py\", line 15, in heuristics_v2\n    heuristics_matrix = negative_weighted_distance_matrix * demand_matrix\n                                 ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\nIndexError: index_select(): Index is supposed to be a vector\n",
      "stdout_file": "coevolve\\generation_9\\stdout_4.txt",
      "code_file": "coevolve\\generation_9\\code_4.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Get the size of the distance matrix\n    n = distance_matrix.size(0)\n    \n    # Create a demand matrix where the demand of each customer is normalized\n    demand_matrix = demands / demands.sum()\n    \n    # Create a matrix for the negative weighted distances\n    negative_weighted_distance_matrix = -distance_matrix\n    \n    # Calculate the heuristics matrix by multiplying the demand matrix with the negative weighted distance matrix\n    heuristics_matrix = negative_weighted_distance_matrix * demand_matrix\n    \n    # Sum along the rows to get the total heuristics for each edge\n    heuristics_matrix = heuristics_matrix.sum(dim=1, keepdim=True)\n    \n    return heuristics_matrix",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 164, in <module>\n    score_optimal, score_student, gap = main_test()\n                                        ^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 105, in main_test\n    score_optimal, score_student, gap = tester.run()\n                                        ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 73, in run\n    score_teacher, score_student, problems_size = self._test_one_batch(\n                                                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 185, in _test_one_batch\n    self.model(state, self.env.selected_node_list, self.env.solution, current_step,\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 102, in forward\n    probs = self.decoder(self.encoded_nodes, selected_node_list,self.capacity, remaining_capacity, attention_bias=self.attention_bias)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 299, in forward\n    attention_bias_current_node_unselect = attention_bias_current_node[torch.arange(batch_size_V)[:, None], unselect_list]  # shape: (B, V-current_step)\n                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: index 1 is out of bounds for dimension 1 with size 1\n",
      "stdout_file": "coevolve\\generation_9\\stdout_5.txt",
      "code_file": "coevolve\\generation_9\\code_5.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the negative weighted distance by multiplying distance by demand\n    # Normalize the demands to sum to 1 for each vehicle\n    demand_normalized = demands / demands.sum()\n    \n    # Create a matrix where each cell represents the weighted distance\n    # We use negative values for the distance matrix to reflect priority\n    negative_weighted_distance = -distance_matrix * demand_normalized\n    \n    # Integrate dynamic load balancing by ensuring that no vehicle is overloaded\n    # This is a simplified approach and does not guarantee an optimal load balance\n    # It simply ensures that the sum of demands for each vehicle does not exceed capacity\n    vehicle_capacity = demands.sum()  # Assuming total capacity is equal to total demand\n    negative_weighted_distance += (vehicle_capacity - demands)[:, None]  # Add penalty for exceeding capacity\n    \n    # Proximity-based route planning by giving priority to edges that are closer\n    # This is done by adding a penalty for edges that are not in the top-k closest edges\n    # For simplicity, we use the k-nearest neighbors approach here\n    k = 5  # Number of closest edges to consider\n    _, top_k_indices = torch.topk(negative_weighted_distance, k, dim=1, largest=False)\n    top_k_edges = negative_weighted_distance.gather(1, top_k_indices)\n    penalty = (negative_weighted_distance - top_k_edges).abs()\n    negative_weighted_distance += penalty\n    \n    return negative_weighted_distance",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Traceback (most recent call last):\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 164, in <module>\n    score_optimal, score_student, gap = main_test()\n                                        ^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2/problems/cvrp_lehd/eval.py\", line 105, in main_test\n    score_optimal, score_student, gap = tester.run()\n                                        ^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 73, in run\n    score_teacher, score_student, problems_size = self._test_one_batch(\n                                                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPTester.py\", line 185, in _test_one_batch\n    self.model(state, self.env.selected_node_list, self.env.solution, current_step,\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1736, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\Conda_data\\envs\\reevo\\Lib\\site-packages\\torch\\nn\\modules\\module.py\", line 1747, in _call_impl\n    return forward_call(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 92, in forward\n    self.attention_bias = torch.stack([\n                                      ^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\VRPModel.py\", line 93, in <listcomp>\n    heuristics(distance_matrices[i], demands[i]) for i in range(distance_matrices.size(0))\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"D:\\ProgramLanguages\\Programs\\Python\\code-gen\\reevo_2\\problems\\cvrp_lehd\\gpt.py\", line 25, in heuristics_v2\n    heuristic_values = dynamic_load_balancing\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nRuntimeError: The size of tensor a (201) must match the size of tensor b (5) at non-singleton dimension 1\n",
      "stdout_file": "coevolve\\generation_9\\stdout_8.txt",
      "code_file": "coevolve\\generation_9\\code_8.py"
    },
    {
      "code": "import torch\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Ensure the demands are normalized\n    total_capacity = demands.sum()\n    normalized_demands = demands / total_capacity\n\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n\n    # Calculate the negative weighted distance based on normalized demand\n    negative_weighted_distance = -distance_matrix * normalized_demands\n\n    # Add a small constant to avoid division by zero\n    epsilon = 1e-8\n    normalized_negative_weighted_distance = (negative_weighted_distance + epsilon) / (negative_weighted_distance + epsilon).sum()\n\n    # Proximity-based heuristic: edges closer to the depot are more promising\n    # We can use the inverse of the distance as the heuristic value\n    inverse_distance = 1 / (distance_matrix + epsilon)\n\n    # Combine the heuristics\n    combined_heuristic = normalized_negative_weighted_distance + inverse_distance\n\n    # Apply dynamic load balancing by reducing the heuristic value for edges that would exceed capacity\n    for i in range(1, len(demands)):\n        for j in range(1, len(demands)):\n            if demands[i] > epsilon:\n                # Calculate the current load if we include this edge\n                current_load = demands[i]\n                for k in range(1, len(demands)):\n                    if k != i and k != j:\n                        current_load += distance_matrix[i, j] * normalized_demands[k]\n                # If the load exceeds capacity, reduce the heuristic value\n                if current_load > 1:\n                    combined_heuristic[i, j] = min(combined_heuristic[i, j], 0)\n\n    return combined_heuristic",
      "fitness": Infinity,
      "execution_success": false,
      "error": "Timeout",
      "stdout_file": "coevolve\\generation_9\\stdout_10.txt",
      "code_file": "coevolve\\generation_9\\code_10.py"
    }
  ]
}